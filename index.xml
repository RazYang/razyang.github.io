<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/"><channel><title>Misc</title><link>https://blog.razyang.com/</link><description>Recent content on Misc</description><generator>Hugo -- 0.152.2</generator><language>en</language><lastBuildDate>Thu, 04 Dec 2025 14:25:04 +0800</lastBuildDate><atom:link href="https://blog.razyang.com/index.xml" rel="self" type="application/rss+xml"/><item><title>[0x01]：nix之路——一个软件包的艺术之旅</title><link>https://blog.razyang.com/posts/nix2/</link><pubDate>Thu, 04 Dec 2025 14:25:04 +0800</pubDate><guid>https://blog.razyang.com/posts/nix2/</guid><description>&lt;p&gt;上一篇文章简单介绍了一下nix核心在做些什么，似乎有些空中楼阁。这次我希望能够通过一个具体的包，让你感受一下，为什么nix这个家伙即使在如此离经叛道的情况下，经过二十多年的发展，狂揽一大批忠实用户和开发者。&lt;/p&gt;
&lt;p&gt;当然，你需要先安装nix，并开启&lt;code&gt;nix-command&lt;/code&gt;以及&lt;code&gt;flakes&lt;/code&gt;两个特性，因为篇幅问题，这部分我就不太赘述了，直接参考&lt;a href="https://docs.determinate.systems/determinate-nix/"&gt;determinate systems的文档&lt;/a&gt;好了。&lt;/p&gt;
&lt;p&gt;本文将带你以最快的速度理解nix的flake机制，准备好了吗？&lt;/p&gt;
&lt;h1 id="hello-nix"&gt;hello nix&lt;/h1&gt;
&lt;p&gt;在我们之前有关“究极构建系统”的设想中，将构建过程抽象成了一个函数，参数是构建依赖，返回值是构建结果。而nix实质上，就是一个函数式的构建系统，函数nix的一等公民。接收参数，返回结果：
&lt;img alt="hello" loading="lazy" src="https://blog.razyang.com/posts/nix2/hello.png"&gt;&lt;/p&gt;
&lt;p&gt;有关上面的代码，你需要理解以下关键内容，更多有关nix语法的介绍可以参考&lt;a href="https://nixos-cn.org/tutorials/lang/QuickOverview.html"&gt;nixos-cn的文档&lt;/a&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;声明了一个函数，以&lt;code&gt;:&lt;/code&gt;为分割，前面为参数，后面为返回值&lt;/li&gt;
&lt;li&gt;函数接收一个&lt;code&gt;属性集&lt;/code&gt;作为参数，其中只有nixpkgs_path一个属性，当不传递任何参数时，改属性的默认值为fetchGit函数的返回结果&lt;/li&gt;
&lt;li&gt;let &amp;hellip; in是一个语法，作用是在一个在有限作用域内声明绑定关系，便于在后面反复使用&lt;/li&gt;
&lt;li&gt;import关键字的作用是从一个路径导入函数，&lt;strong&gt;如果路径是一个目录，则导入default.nix&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;nixpkgs是一个使用nix语言编写的代码仓库，其中包含了超过&lt;a href="https://search.nixos.org/packages"&gt;12万个包&lt;/a&gt;的构建代码&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;那这个函数做了什么呢？其实什么也没做什么复杂的事情:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;使用git下载一个目录&lt;/li&gt;
&lt;li&gt;将目录导入为函数，调用得到pkgs&lt;/li&gt;
&lt;li&gt;返回pkgs中的hello&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;这个函数可以说是最简单的构建函数，什么也不做，只把构建参数直接返回。调用函数也很简单：
&lt;img alt="hello derivation" loading="lazy" src="https://blog.razyang.com/posts/nix2/hello_drv.png"&gt;&lt;/p&gt;
&lt;p&gt;看我们的函数返回了一个什么，&lt;code&gt;.drv&lt;/code&gt;？不要怕，如果你读过上一篇【nix之路——究极构建系统】，这个东西就是之前提及的&lt;code&gt;.bld&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;使用&lt;code&gt;nix derivation show&lt;/code&gt;可以将这个文件转换为json查看：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;nixpkgs仓库比较大，下载需要多等待一会儿
&lt;img alt="derivation show" loading="lazy" src="https://blog.razyang.com/posts/nix2/derivation_show.png"&gt;
当然，直接指定绝对路径也可以:
&lt;img alt="derivation show" loading="lazy" src="https://blog.razyang.com/posts/nix2/derivation_show_2.png"&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;所以说，&lt;code&gt;pkgs.hello&lt;/code&gt;实际上对应一个&lt;code&gt;.drv&lt;/code&gt;文件，这个文件包含了能够构建这个包的所有信息。那我们如何最终构建他呢？也很简单：
&lt;img alt="build hello" loading="lazy" src="https://blog.razyang.com/posts/nix2/build_hello.png"&gt;&lt;/p&gt;
&lt;p&gt;构建完成后，默认会在当前目录建立一个指向产物目录的软连接，让我们可以快速使用&lt;/p&gt;
&lt;p&gt;当然，以上只是为了让你更好的理解nix代码和产物的关系，实际上用下面的命令可以构建出一样的结果：
&lt;img alt="one liner" loading="lazy" src="https://blog.razyang.com/posts/nix2/one_liner_build.png"&gt;&lt;/p&gt;
&lt;h1 id="hello-flakenix"&gt;hello flake.nix&lt;/h1&gt;
&lt;p&gt;也许你发现了，上面我们每次调用default.nix的时候，都要重新下载nixpkgs。而且，函数参数的默认值是一个下载函数，感觉哪里怪怪的。&lt;/p&gt;
&lt;p&gt;其实nix提供了一种更好的的，导入外部nix代码依赖的机制，叫做&lt;code&gt;flake&lt;/code&gt;，不同于default.nix，当指定一个目录时，&lt;code&gt;flake.nix&lt;/code&gt;是默认的入口文件。他的格式也很简单：
&lt;img alt="hello flake" loading="lazy" src="https://blog.razyang.com/posts/nix2/hello_flake.png"&gt;&lt;/p&gt;
&lt;p&gt;这个文件核心在于&lt;code&gt;inputs&lt;/code&gt;以及&lt;code&gt;outputs&lt;/code&gt;两部分&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;inputs&lt;/code&gt;
inputs声明了需要的外部nix代码仓库地址，地址可以是git仓库、本地路径、压缩包、压缩包下载链接等等&lt;/li&gt;
&lt;li&gt;&lt;code&gt;outputs&lt;/code&gt;
outputs很显然是一个函数，就像上面我们写的default.nix一样，他接收一个&lt;code&gt;属性集&lt;/code&gt;作为参数，属性来自&lt;code&gt;inputs&lt;/code&gt;中的声明，最后返回一个属性集。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;也许你注意到了，不同于我们自己写的&lt;code&gt;default.nix&lt;/code&gt;，这里的参数多出了一个&lt;code&gt;self&lt;/code&gt;属性，我们可以简单模拟一下&lt;code&gt;flake.nix&lt;/code&gt;的执行过程：
&lt;img alt="call_flake" loading="lazy" src="https://blog.razyang.com/posts/nix2/call_flake.png"&gt;
等等等等，发生了什么？这里的&lt;code&gt;fix&lt;/code&gt;函数其实是nix语言中的一个常用trick，称为&lt;code&gt;fix point&lt;/code&gt;，既然你早晚要面对他，我决定在这里直接告诉你它的存在。&lt;/p&gt;
&lt;p&gt;不过，我并不打算在这里过分展开&lt;code&gt;fix point&lt;/code&gt;的原理，有关&lt;code&gt;fix point&lt;/code&gt;的原理，我看过比较好的介绍是&lt;a href="https://akavel.github.io/post/nix-fixpoint/"&gt;akavel的这篇文章&lt;/a&gt;，你可以选择去深入了解一下。&lt;/p&gt;
&lt;p&gt;如果你暂时还不想知道&lt;code&gt;fix&lt;/code&gt;干了什么，只需要知道它的效果就可以了，在这里我们尝试使用我们的&lt;code&gt;call_flake.nix&lt;/code&gt;调用一下flake.nix，看看发生了什么：
&lt;img alt="flake self" loading="lazy" src="https://blog.razyang.com/posts/nix2/flake_self.png"&gt;&lt;/p&gt;
&lt;p&gt;可以看到，如果我们在ouptuts的返回值中导出self，这个self就不断指向返回结果自己。这样可以让你很方便的在outputs的实现中，引用自己对外导出的部分。&lt;/p&gt;
&lt;p&gt;好了，小插曲到此为止，还是让我们看一下如何正常操作&lt;code&gt;flake.nix&lt;/code&gt;吧：&lt;/p&gt;
&lt;p&gt;首先，使用&lt;code&gt;nix flake show&lt;/code&gt;可以查看flake中outputs函数的返回结果，&lt;a href="https://nix.dev/manual/nix/2.32/command-ref/new-cli/nix3-flake-check.html"&gt;但默认支持的类型有限&lt;/a&gt;,其他不支持展示的属性只能展示为&lt;code&gt;unknown&lt;/code&gt;：
&lt;img alt="flake_show" loading="lazy" src="https://blog.razyang.com/posts/nix2/flake_show.png"&gt;&lt;/p&gt;
&lt;p&gt;如果你想知道flake的详细返回内容是什么怎么办？你可以调用nix repl，使用&lt;code&gt;:lf&lt;/code&gt;来调用&lt;code&gt;flake.nix&lt;/code&gt;，获取返回值：
&lt;a href="nix_repl_flake.png"&gt;nix_repl_flake&lt;/a&gt;&lt;/p&gt;
&lt;h1 id="一个软件包的艺术之旅"&gt;一个软件包的艺术之旅&lt;/h1&gt;
&lt;p&gt;我们现在知道&lt;code&gt;flake&lt;/code&gt;机制的运作原理，以及如何将gnu hello作为&lt;code&gt;packages.${system}.hello&lt;/code&gt;作为flake的返回值返回，那我们都可以对这个包做些什么操作呢？&lt;/p&gt;
&lt;p&gt;首先，我们可以使用&lt;code&gt;nix build&lt;/code&gt;快速构建一个flake仓库导出的包，构建后默认会在当前目录建立一个指向构建产物的软链接：
&lt;img alt="nix_build" loading="lazy" src="https://blog.razyang.com/posts/nix2/nix_build.png"&gt;
你也可以选择使用&lt;code&gt;nix run&lt;/code&gt;直接运行它，运行前他也会检查是否构建过，如果没构建会先构建再执行：
&lt;img alt="nix_run" loading="lazy" src="https://blog.razyang.com/posts/nix2/nix_run.png"&gt;
也可以使用&lt;code&gt;nix derivation show&lt;/code&gt;查看这个包对应的&lt;code&gt;.drv&lt;/code&gt;文件：
&lt;img alt="nix_derivation_show" loading="lazy" src="https://blog.razyang.com/posts/nix2/nix_derivation_show.png"&gt;
你也可以将某个包，以及他的所有运行时依赖拷贝到别处，只需要一个内核就可以运行，可以使用chroot验证一下：
&lt;img alt="nix_copy" loading="lazy" src="https://blog.razyang.com/posts/nix2/nix_copy.png"&gt;
当然，nixpkgs本身也是一个flake仓库，&lt;a href="https://search.nixos.org/packages"&gt;nixpkgs仓库中任何包&lt;/a&gt;都可以用上面的方式操作：
&lt;img alt="neovim" loading="lazy" src="https://blog.razyang.com/posts/nix2/neovim.png"&gt;&lt;/p&gt;</description></item><item><title>[0x01]：nix之路——究极构建系统</title><link>https://blog.razyang.com/posts/nix1/</link><pubDate>Sat, 22 Nov 2025 15:09:04 +0800</pubDate><guid>https://blog.razyang.com/posts/nix1/</guid><description>&lt;h1 id="构建的本质"&gt;构建的本质&lt;/h1&gt;
&lt;p&gt;让我们先忘掉nix，假设我们现在要设计一个究极的构建系统，能构建计算机领域的任何东西。为了实现这个伟大的目标，我们首先要思考一下，什么是“构建”&lt;/p&gt;
&lt;p&gt;拿最简单的hello world举例。我们写完了hello world的源码，这个源码是如何变为产物的？&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"&gt;&lt;code class="language-bash" data-lang="bash"&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;$ gcc hello.c -o hello
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;似乎很简单，只要有一个源码，有一个构建工具，就可以输出最终产物:&lt;/p&gt;
&lt;p&gt;&lt;img alt="easy_one" loading="lazy" src="https://blog.razyang.com/posts/nix1/easy_one.svg"&gt;&lt;/p&gt;
&lt;p&gt;ELF是构建产物，那压缩包呢？似乎也是一个道理，只不过构建依赖中有压缩工具而已&lt;/p&gt;
&lt;p&gt;压缩包是构建产物，那容器镜像呢？好像也一样，无非也就是多引入几个工具，里面包含一个rootfs，生成一个特殊格式的压缩包而已&lt;/p&gt;
&lt;p&gt;容器镜像是构建产物，操作系统呢？好像也差不多，只不过是依赖多了一些。&lt;/p&gt;
&lt;p&gt;可以说掌握了构建的本质，就掌握了能够构建所有东西的理论基础&lt;/p&gt;
&lt;h1 id="hello-world"&gt;hello world!&lt;/h1&gt;
&lt;p&gt;你可能说，问题才没那么简单！让我们拿最简单的hello world程序举例&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"&gt;&lt;code class="language-c" data-lang="c"&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;&lt;span style="color:#75715e"&gt;#include&lt;/span&gt; &lt;span style="color:#75715e"&gt;&amp;lt;stdio.h&amp;gt;&lt;/span&gt;&lt;span style="color:#75715e"&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;&lt;span style="color:#75715e"&gt;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;&lt;span style="color:#66d9ef"&gt;int&lt;/span&gt; &lt;span style="color:#a6e22e"&gt;main&lt;/span&gt;() {
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt; &lt;span style="color:#a6e22e"&gt;printf&lt;/span&gt;(&lt;span style="color:#e6db74"&gt;&amp;#34;hello world&lt;/span&gt;&lt;span style="color:#ae81ff"&gt;\n&lt;/span&gt;&lt;span style="color:#e6db74"&gt;&amp;#34;&lt;/span&gt;);
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt; &lt;span style="color:#66d9ef"&gt;return&lt;/span&gt; &lt;span style="color:#ae81ff"&gt;0&lt;/span&gt;;
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;stdio.h哪里来呢，这个应该算作什么呢？然后我们看一下hello的动态链接情况&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"&gt;&lt;code class="language-bash" data-lang="bash"&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;$ ldd hello
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt; linux-vdso.so.1 &lt;span style="color:#f92672"&gt;(&lt;/span&gt;0x00007ffcda3d9000&lt;span style="color:#f92672"&gt;)&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt; libc.so.6 &lt;span style="color:#f92672"&gt;=&lt;/span&gt;&amp;gt; /lib64/libc.so.6 &lt;span style="color:#f92672"&gt;(&lt;/span&gt;0x00007b5716402000&lt;span style="color:#f92672"&gt;)&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt; /lib64/ld-linux-x86-64.so.2 &lt;span style="color:#f92672"&gt;(&lt;/span&gt;0x00007b5716606000&lt;span style="color:#f92672"&gt;)&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;libc.so.6以及ld-linux-x86-64.so.2算作什么呢？似乎不只运行阶段，我们构建的时候也需要这些文件&lt;/p&gt;
&lt;p&gt;好好好，让我们弥补一下：&lt;/p&gt;
&lt;p&gt;&lt;img alt="complex_one" loading="lazy" src="https://blog.razyang.com/posts/nix1/complex_one.svg"&gt;&lt;/p&gt;
&lt;p&gt;在上面这张图中，我将gcc也算作了构建依赖，使用bash脚本作为构建器，其中可能使用mkdir之类的命令，所以说可能也需要coreutils作为构建依赖，实际问题可能会更复杂，但总体来说都能总结为（源码+依赖 -&amp;gt; 产物）&lt;/p&gt;
&lt;h1 id="究极的构建系统"&gt;究极的构建系统&lt;/h1&gt;
&lt;p&gt;很好，很好，很好。现在我们既理解了构建的本质，也有了hello world的实际例子，理论与实践相结合，现在离目标的“究极构建系统”就差一个程序员了。&lt;/p&gt;
&lt;h2 id="meta-builder-v001"&gt;Meta Builder (v0.0.1)&lt;/h2&gt;
&lt;p&gt;实现似乎也很简单，把构建过程封装成一个函数，成果物就是函数的返回值：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"&gt;&lt;code class="language-go" data-lang="go"&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;&lt;span style="color:#75715e"&gt;// ...&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;&lt;span style="color:#a6e22e"&gt;seed&lt;/span&gt; = &lt;span style="color:#a6e22e"&gt;downloadUrl&lt;/span&gt;(&lt;span style="color:#e6db74"&gt;&amp;#34;https://example.com/bootstrap-seed.tar.gz&amp;#34;&lt;/span&gt;)
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;(&lt;span style="color:#a6e22e"&gt;gcc&lt;/span&gt;,&lt;span style="color:#a6e22e"&gt;make&lt;/span&gt;,&lt;span style="color:#a6e22e"&gt;glibc&lt;/span&gt;,&lt;span style="color:#a6e22e"&gt;autoconf&lt;/span&gt;,&lt;span style="color:#a6e22e"&gt;m4&lt;/span&gt;,&lt;span style="color:#a6e22e"&gt;bash&lt;/span&gt;,&lt;span style="color:#a6e22e"&gt;coreutils&lt;/span&gt;) &lt;span style="color:#f92672"&gt;:=&lt;/span&gt; &lt;span style="color:#a6e22e"&gt;mkPackage&lt;/span&gt;(&lt;span style="color:#a6e22e"&gt;seed&lt;/span&gt;)
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;&lt;span style="color:#75715e"&gt;// 源码来源无所谓，只要能返回值类型一致就可以&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;&lt;span style="color:#a6e22e"&gt;hello_src&lt;/span&gt; = &lt;span style="color:#a6e22e"&gt;downloadUrl&lt;/span&gt;(&lt;span style="color:#e6db74"&gt;&amp;#34;mirror://gnu/hello/hello-2.12.2.tar.gz&amp;#34;&lt;/span&gt;)
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;&lt;span style="color:#a6e22e"&gt;hello&lt;/span&gt; &lt;span style="color:#f92672"&gt;:=&lt;/span&gt; &lt;span style="color:#a6e22e"&gt;mkPackage&lt;/span&gt;(&lt;span style="color:#a6e22e"&gt;hello_src&lt;/span&gt;,&lt;span style="color:#a6e22e"&gt;gcc&lt;/span&gt;,&lt;span style="color:#a6e22e"&gt;bash&lt;/span&gt;,&lt;span style="color:#a6e22e"&gt;coreutils&lt;/span&gt;,&lt;span style="color:#a6e22e"&gt;make&lt;/span&gt;,&lt;span style="color:#a6e22e"&gt;autoconf&lt;/span&gt;)
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;&lt;span style="color:#75715e"&gt;// 当然，动态链接库依赖也没问题&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;&lt;span style="color:#a6e22e"&gt;libanything_src&lt;/span&gt; = &lt;span style="color:#a6e22e"&gt;downloadUrl&lt;/span&gt;(&lt;span style="color:#e6db74"&gt;&amp;#34;...&amp;#34;&lt;/span&gt;)
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;&lt;span style="color:#a6e22e"&gt;libanything&lt;/span&gt; = &lt;span style="color:#a6e22e"&gt;mkPackage&lt;/span&gt;(&lt;span style="color:#a6e22e"&gt;libanything_src&lt;/span&gt;,&lt;span style="color:#f92672"&gt;...&lt;/span&gt;)
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;&lt;span style="color:#a6e22e"&gt;anything_src&lt;/span&gt; = &lt;span style="color:#a6e22e"&gt;downloadUrl&lt;/span&gt;(&lt;span style="color:#e6db74"&gt;&amp;#34;...&amp;#34;&lt;/span&gt;)
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;&lt;span style="color:#a6e22e"&gt;anything&lt;/span&gt; = &lt;span style="color:#a6e22e"&gt;mkPackage&lt;/span&gt;(&lt;span style="color:#a6e22e"&gt;anything_src&lt;/span&gt;,&lt;span style="color:#a6e22e"&gt;libanything&lt;/span&gt;,&lt;span style="color:#f92672"&gt;...&lt;/span&gt;)
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;&lt;span style="color:#75715e"&gt;// 究极构建系统，当然要可以自举了&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;&lt;span style="color:#a6e22e"&gt;bootstrap_seed&lt;/span&gt; = &lt;span style="color:#a6e22e"&gt;mkPackage&lt;/span&gt;(&lt;span style="color:#f92672"&gt;...&lt;/span&gt;)
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;以上代码描绘了这样一套系统：&lt;/p&gt;</description></item><item><title>[0x00]：nix之路——为什么我要学习nix</title><link>https://blog.razyang.com/posts/nix0/</link><pubDate>Sat, 22 Nov 2025 14:24:11 +0800</pubDate><guid>https://blog.razyang.com/posts/nix0/</guid><description>&lt;h1 id="为什么我要学习nix"&gt;为什么我要学习nix&lt;/h1&gt;
&lt;p&gt;还记得大学开学拿到自己第一台笔记本电脑时候，当时兴高采烈的打算装上visual studio开始探索计算机世界，但反反复复失败之后，我最后决定把windows干掉安装linux。 接下来，一台笔记本，一个Linux系统的配置就伴随了我整个大学时光。&lt;/p&gt;
&lt;p&gt;当然，在使用期间免不了喜欢配置各种桌面系统、探索各种命令行软件、重装各种发行版。常见的比如ubuntu、fedora、archlinux、opensuse、Elementary OS，还有少见一点的例如Qubes OS、clear os、fedora silverblue，可以说各式各样的发行版都玩过一遍。&lt;/p&gt;
&lt;p&gt;整个过程下来，我逐渐感受到，不同发行版之间的区别，无非也就是包管理的区别和其中维护的包集合数量/质量之间的区别。&lt;/p&gt;
&lt;p&gt;然而在当时尝试的众多发行版中，有这样一个发行版，每次都让我望而却步，却又充满了好奇，那就是nixos。nixos很不一样，他用的nix包管理与其说是一个包管理，不如说是一个终极的构建工具，而nixos恰好是nix打出来的一种产物而已。&lt;/p&gt;
&lt;p&gt;虽然现在nix的github主页的介绍中写着&amp;quot;Nix, the purely functional package manager&amp;quot;，不过我觉得这个介绍可能过于狭隘，最开始Eelco Dolstra的论文题目是&amp;quot;The Purely Functional Software Deployment Model&amp;quot;，两个表述之间，孰强孰弱立马见分晓。&lt;/p&gt;
&lt;p&gt;不过就像我前面所说，当时我只是知道有这么一个神奇的发行版，使用非FHS的目录结构，其他什么“可重现”，“原子升级”，“声明式”之类词汇虽然挺起来高大上，但是这和我又有什么关系呢？毕竟这是一个正常ELF文件都没办法在上面跑的操作系统。&lt;/p&gt;
&lt;p&gt;若干年后，在我经历了各种交叉编译、静态链接、各种操作系统适配问题、容器镜像构建问题之后，我一步一步的走向nix。并且笃定的认为nix正在成为计算机领域的下一代构建技术，并且将会杀死发行版这个概念。&lt;/p&gt;
&lt;p&gt;对于我来说，学习nix的过程从来不是容易的。在2018年左右，我第一次尝试安装nixos，当时觉得自己连archlinux安装都没什么问题，无非也就是照着官网的文档一步一步来，但很快我就发现，在nixos中似乎常规的linux技巧都失效了，一切都被一个巨大的配置文档所支配，我完全无法理解背后到底发生了什么。&lt;/p&gt;
&lt;p&gt;后来，尝试去读nix pills文档，读Eelco Dolstra的论文，尝试理解nix的基本概念，但也一知半解。再后来nix推出了flake，虽然我一向喜欢一些高概念的事物，但是nix相关的概念之复杂，最开始真的让我无从下手。然而这一切直到我开始阅读nixpkgs代码，以及一点一点开始编写nix代码之后才缓解，终于能将各种基本概念映射到实际了。&lt;/p&gt;
&lt;p&gt;而这个系列（如果顺利的话），将介绍nix的一些基本概念，后续可能还会加上一些基本的使用场景和使用技巧，帮助还没有接触nix或者已经接触nix但对其原理还不太清楚的人更快的进入nix的领域。我希望通过这个系列文章能够让你认识到nix的本质，或者说让你更接近nix的本质，而不是被表面上眼花缭乱的封装搞得晕头转向，就像我最开始了解nix时的那样。&lt;/p&gt;</description></item><item><title>Nix and Content Address</title><link>https://blog.razyang.com/posts/nix-and-content-address/</link><pubDate>Fri, 08 Dec 2023 16:34:44 +0800</pubDate><guid>https://blog.razyang.com/posts/nix-and-content-address/</guid><description>&lt;h1 id="nix目前的构建和发布模型"&gt;Nix目前的构建和发布模型&lt;/h1&gt;
&lt;h2 id="derivation-outputs-and-output-paths"&gt;&lt;code&gt;derivation outputs&lt;/code&gt; and &lt;code&gt;output paths&lt;/code&gt;&lt;/h2&gt;
&lt;p&gt;Nix软件构建以Derivation为核心，Derivation有以下核心属性：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;Derivation表示了软件的构建过程；&lt;/li&gt;
&lt;li&gt;Derivation可以依赖其他Derivation；&lt;/li&gt;
&lt;li&gt;Derivation执行后具有副作用，会在&lt;code&gt;/nix/store&lt;/code&gt;下生成路径为&lt;code&gt;xxx-name.drv&lt;/code&gt;的文件，其中xxx为该Derivation的唯一标识符，在任何电脑中都一致；&lt;/li&gt;
&lt;li&gt;&lt;code&gt;xxx-name.drv&lt;/code&gt;可以被进一步构建成产物，并且产物的路径存储在&lt;code&gt;xxx-name.drv&lt;/code&gt;中，在构建前就可以知道，此处我们称为&lt;code&gt;outPath&lt;/code&gt;；&lt;/li&gt;
&lt;li&gt;&lt;code&gt;outPath&lt;/code&gt;路径中也存在唯一标识，同一个Derrvation产生的&lt;code&gt;.drv&lt;/code&gt;文件中的&lt;code&gt;outPath&lt;/code&gt;一定相同；&lt;/li&gt;
&lt;li&gt;由于构建前就知道产物路径，引用某个derivation时，只要检查其中存储的&lt;code&gt;outPath&lt;/code&gt;存不存在，就可以判定需不需要重复编译；&lt;/li&gt;
&lt;li&gt;不同机器可以通过共享&lt;code&gt;outPath&lt;/code&gt;来共享构建缓存；&lt;/li&gt;
&lt;/ol&gt;
&lt;blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;这里存在两个目录，一个是&lt;code&gt;.drv&lt;/code&gt;的目录，一个是&lt;code&gt;outPath&lt;/code&gt;的目录，两者的路径中都有唯一标识符，且路径都根据Derivation的参数计算得来，&lt;code&gt;outPath&lt;/code&gt;存储在&lt;code&gt;.drv&lt;/code&gt;中。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/blockquote&gt;
&lt;h2 id="构建过程"&gt;构建过程&lt;/h2&gt;
&lt;p&gt;nix包管理的软件构建过程用伪码表示大致如下:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"&gt;&lt;code class="language-python" data-lang="python"&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;derivation &lt;span style="color:#f92672"&gt;=&lt;/span&gt; getDerivationFrom(nixpkgs, package_name)
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;drv &lt;span style="color:#f92672"&gt;=&lt;/span&gt; derivatoin() &lt;span style="color:#75715e"&gt;# 此处存在副作用，derivation函数调用后会生成.drv文件&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;&lt;span style="color:#66d9ef"&gt;if&lt;/span&gt; checkOutPathExist(drv&lt;span style="color:#f92672"&gt;.&lt;/span&gt;outPath):
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt; &lt;span style="color:#66d9ef"&gt;pass&lt;/span&gt; &lt;span style="color:#75715e"&gt;# 如果产物目录已经存在，就不用重复构建了&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;&lt;span style="color:#66d9ef"&gt;else&lt;/span&gt;:
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt; drv&lt;span style="color:#f92672"&gt;.&lt;/span&gt;build() &lt;span style="color:#75715e"&gt;# drv.build()会将软件构建后放到drv.outPath中&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;binary cache引入后:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"&gt;&lt;code class="language-python" data-lang="python"&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;derivation &lt;span style="color:#f92672"&gt;=&lt;/span&gt; getDerivationFrom(nixpkgs, package_name)
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;drv &lt;span style="color:#f92672"&gt;=&lt;/span&gt; derivatoin()
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;&lt;span style="color:#66d9ef"&gt;if&lt;/span&gt; checkOutPathExist(drv&lt;span style="color:#f92672"&gt;.&lt;/span&gt;outPath):
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt; &lt;span style="color:#66d9ef"&gt;pass&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;&lt;span style="color:#66d9ef"&gt;else&lt;/span&gt;:
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt; &lt;span style="color:#66d9ef"&gt;if&lt;/span&gt; fetchOutPathFromBinaryCache(drv&lt;span style="color:#f92672"&gt;.&lt;/span&gt;outPath):
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt; &lt;span style="color:#66d9ef"&gt;pass&lt;/span&gt; &lt;span style="color:#75715e"&gt;# 尝试从BinaryCache服务器中下载对应的包，放到outPath中&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt; &lt;span style="color:#66d9ef"&gt;else&lt;/span&gt;:
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt; drv&lt;span style="color:#f92672"&gt;.&lt;/span&gt;build()
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h1 id="input-address-model"&gt;Input-Address Model&lt;/h1&gt;
&lt;p&gt;总体来说，上面我们描述的目前Nix的做法是将软件构建软件的过程（包括输入）抽象为一个哈希值，这个唯一哈希值可以代表软件的某个特定状态，然后用这个哈希值来索引构建后的软件。&lt;/p&gt;
&lt;p&gt;在构建过程当中，任何输入的改变必然会导致输出的路径发生变化：
&lt;img alt="input address model" loading="lazy" src="https://blog.razyang.com/posts/nix-and-content-address/input_address.svg"&gt;
&lt;img alt="input address model" loading="lazy" src="https://blog.razyang.com/posts/nix-and-content-address/input_address_dependencies_change.svg"&gt;&lt;/p&gt;
&lt;h2 id="过度重复构建"&gt;过度重复构建&lt;/h2&gt;
&lt;p&gt;你可能已经意识到了一些不对，在正常的软件构建过程当中，输入的改变不一定会导致输出不同，比如说代码路径下面增加了一些文档，或者说构建流程发生了改变。&lt;/p&gt;
&lt;p&gt;然而在Nix目前的构建模型中，输入的任何变化都会导致输出路径的变化，但现实当中这样往往会导致一些不好的副作用。&lt;/p&gt;
&lt;p&gt;例如go语言的源码中使用perl来做代码单元测试，原则上来说，使用什么版本的perl做单元测试，或者是否做单元测试，都不会改变构建产物。我们可以认为，源码中不是所有改动都会影响产物。但在nix中，如果perl包发生了改变，而go又依赖perl做单元测试，那么go的产物路径就会发生变化，进而需要重新编译。再进一步，所有依赖go的包也需要重新编译，导致了很多没有必要的重复编译。&lt;/p&gt;
&lt;h1 id="content-address-model"&gt;Content-Address Model&lt;/h1&gt;
&lt;p&gt;解决上述问题的方式思路也很简单，就是使用content address的方式来确定构建缓存的实际目录。&lt;/p&gt;
&lt;p&gt;所谓content address，与input address相对。在input address的模型中，用于索引value的key与value内容无关；
但在content address的模型中，用于索引value的key是根据value的内容计算得来。content address最简单的例子就是使用文件的哈希值来索引文件，给定文件的哈希值，返回文件内容；
而input address典型例子就是给定文件的文件名，返回文件的内容；&lt;/p&gt;</description></item><item><title>Way to Nix 1</title><link>https://blog.razyang.com/posts/way-to-nix-1/</link><pubDate>Fri, 01 Dec 2023 11:56:15 +0800</pubDate><guid>https://blog.razyang.com/posts/way-to-nix-1/</guid><description>&lt;p&gt;最近学习了一些Nix相关的东西，把家里大多数机器都切到了nixos上，感觉很不错。但是由于nix文档比较差，写自己配置的时候，很多时候需要看代码，或者抄别人的配置一点点凑，过程当中遇到了不少问题。也学习了不少Nix的基本概念，于是记录一下相关的概念和技术以免忘记。&lt;/p&gt;
&lt;p&gt;前阵子看过NickCao的前些年的一个视频，非常有条例的介绍了一些nix的基本概念，有兴趣可以去看一下：&lt;a href="https://b23.tv/vxaiTuS"&gt;【金枪鱼之夜：Nix - 从构建系统到配置管理-哔哩哔哩】&lt;/a&gt;&lt;/p&gt;
&lt;h1 id="nix-as-a-build-systems"&gt;Nix as a build systems&lt;/h1&gt;
&lt;p&gt;构建系统一般就是指从源码生成产物的一套工具生态集合，就拿Makefile举例，几乎所有的构建过程都可以描述成如下形式的嵌套结构：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"&gt;&lt;code class="language-Makefile" data-lang="Makefile"&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;&lt;span style="color:#a6e22e"&gt;构建目标&lt;/span&gt;&lt;span style="color:#f92672"&gt;:&lt;/span&gt; 构建原料
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt; 构建过程
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;围绕着gnu make，有一套完整的，有着悠久历史的构建系统，如GNU Autoconf，Cmake等，许多现代语言也包含了自己的构建系统，如rust的cargo，go的build，js的npm等等。也会有许多项目选择多种构建系统嵌套，如Cmake生成makefile调用Cargo来进行项目构建。&lt;/p&gt;
&lt;h2 id="derivation"&gt;Derivation&lt;/h2&gt;
&lt;p&gt;也许nix里最重要的概念就是&lt;a href="https://nixos.org/manual/nix/stable/language/derivations.html"&gt;Derivation&lt;/a&gt;了，它与nix中的很多概念相互关联，并作为纽带。可以说理解了Derivation，至少就理解了Nix的半壁江山。&lt;/p&gt;
&lt;p&gt;首先， derivition是nix中的一个内置函数,代码实现位于(&lt;a href="https://github.com/NixOS/nix/blob/188c803ddb5e63b243ddb84eba9b70e45475b7ea/src/libexpr/primops/derivation.nix#L2"&gt;https://github.com/NixOS/nix/blob/188c803ddb5e63b243ddb84eba9b70e45475b7ea/src/libexpr/primops/derivation.nix#L2&lt;/a&gt;)，实际调用的是内部C++函数&lt;a href="https://github.com/NixOS/nix/blob/188c803ddb5e63b243ddb84eba9b70e45475b7ea/src/libexpr/primops.cc#L1041"&gt;prim_derivationStrict&lt;/a&gt;:&lt;/p&gt;
&lt;pre tabindex="0"&gt;&lt;code class="language-repl" data-lang="repl"&gt;nix-repl&amp;gt; derivation
«lambda @ /builtin/derivation.nix:5:1»
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;与其他构建系统类似，derivation包含了构建原料，构建目标以及构建过程，调用这个函数必须有&lt;code&gt;name&lt;/code&gt;、&lt;code&gt;system&lt;/code&gt;以及&lt;code&gt;builder&lt;/code&gt;三个必选参数，其他可选参数可参考&lt;a href="https://nixos.org/manual/nix/stable/language/derivations.html#optional"&gt;Nix Reference Manual&lt;/a&gt;:&lt;/p&gt;
&lt;pre tabindex="0"&gt;&lt;code&gt;nix-repl&amp;gt; derivation {name = &amp;#34;target_name&amp;#34;;system=&amp;#34;x86_64-linux&amp;#34;; builder=&amp;#34;builder_binary&amp;#34;;}
«derivation /nix/store/6z9jj5khn7j3xi2fv8fibpzj6gnq4iz4-target_name.drv»
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;值得注意的是，derivation函数存在一个副作用，即在/nix/store/目录下生成一个以&lt;code&gt;.drv&lt;/code&gt;为后缀的文件，并且文件名中包含了一个类似哈希的字符串，保证路径的唯一性。derivation有如下属性:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;同样参数的derivation函数调用后生成的文件，路径一定是一样的（&lt;em&gt;在哈希算法的保证下，可以假定不同参数调用derivation产生的drv文件路径一定是不同的&lt;/em&gt;）&lt;/li&gt;
&lt;li&gt;derivation中包含的所有参数必须为字面量，或预先可以确定哈希值的固定内容（&lt;strong&gt;Fixed-Output Derivations&lt;/strong&gt;）&lt;/li&gt;
&lt;li&gt;derivation可以互相依赖，一个derivation可以依赖另外一个derivation&lt;/li&gt;
&lt;li&gt;derivation可以被执行，类似Makefile一样可以被构建&lt;/li&gt;
&lt;li&gt;derivation会被在隔离的环境执行，其中没有类似&lt;code&gt;/bin/bash&lt;/code&gt;之类可以预先假定存在的路径，能且只能通过derivation依赖的方式在构建过程当中引入其他软件&lt;/li&gt;
&lt;li&gt;derivation执行后会产生两个关键参数，out.out以及out.outPath，一个存储了drv的路径，一个存储了构建产物的路径&lt;/li&gt;
&lt;/ul&gt;
&lt;pre tabindex="0"&gt;&lt;code&gt;nix-repl&amp;gt; d = derivation {name = &amp;#34;target_name&amp;#34;;system=&amp;#34;x86_64-linux&amp;#34;; builder=&amp;#34;builder_binary&amp;#34;;}
nix-repl&amp;gt; d.out.out
«derivation /nix/store/6z9jj5khn7j3xi2fv8fibpzj6gnq4iz4-target_name.drv»
nix-repl&amp;gt; d.out.outPath
&amp;#34;/nix/store/pd5l9rzb613v5lv4c6q2m0c81zd9w3l6-target_name&amp;#34;
nix-repl&amp;gt; d.out.out == d
true
nix-repl&amp;gt; d.out == d
true
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;以上属性组合的结果，使得nix构建系统存在如下特性：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;任何软件的derivation在/nix/store中的路径包含了唯一哈希值，这个路径实际上代表了产物是用&lt;code&gt;何种输入源&lt;/code&gt;，以&lt;code&gt;何种构建方式&lt;/code&gt;，配置&lt;code&gt;何种构建参数&lt;/code&gt;所构建出来的结果，且由于derivation之间互相依赖，整颗依赖树的任何一个环节发生了变化，重新构建后，derivation路径相应也会发生变化&lt;/li&gt;
&lt;li&gt;derivation既可以描述软件的构建过程，又可以描述多种软件组合称为操作系统的过程，进一步说，如果把操作系统当成目标产物，通过derivation的嵌套，nix可以描述出整个操作系统的构建过程，且在保证可完全可复现。&lt;/li&gt;
&lt;/ol&gt;
&lt;h1 id="nix-as-programing-language"&gt;Nix as programing language&lt;/h1&gt;
&lt;p&gt;与其他构建系统采用的语法风格不同的是，Nix采用了函数式语法，且没有类型系统，这也是Nix看起来比较吓人的主要原因&lt;/p&gt;</description></item><item><title>叛逃</title><link>https://blog.razyang.com/posts/defection/</link><pubDate>Sun, 07 Aug 2022 12:52:43 +0800</pubDate><guid>https://blog.razyang.com/posts/defection/</guid><description>&lt;h1 id="所谓叛逃"&gt;所谓叛逃&lt;/h1&gt;
&lt;p&gt;仔细想一想，自从上大学开始，我用linux做为日常工作和学习的系统也有将近六年了。
这六年来，常见的Linux发行版基本都装了个遍，常见的桌面环境和窗口管理器也基本用了个遍。
不过随着时间流逝，我逐渐发现，桌面环境折腾无数遍，其实实际在用的图形界面软件只有三个：&lt;code&gt;emacs&lt;/code&gt;、&lt;code&gt;chrome&lt;/code&gt;、&lt;code&gt;alacritty&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;更抽象一点的话，其实就是一个编辑器，一个浏览器还有一个终端模拟器。其他软件使用频率都非常低，最近两年内，我逐渐发现自己打开文件管理器的频率也越来越低，以至于文件管理器对于我日常的电脑使用来说，也成为了一个没有必要的软件。&lt;/p&gt;
&lt;p&gt;铺垫了这么多，其实我就是想说，爷叛逃了，到MacOS。&lt;/p&gt;
&lt;h1 id="目的地"&gt;目的地&lt;/h1&gt;
&lt;p&gt;其实也没啥道理，最近想买一个笔记本，看了一圈。intel 11代摆大烂，12代功耗爆炸；AMD 6000系的笔记本，续航稍微好一些，但GPU硬件设计有问题。仔细想了一想，苹果的笔记本成了这两年唯一没重大问题，没开过什么倒车的设备了。&lt;/p&gt;
&lt;p&gt;所以，Macbook Air m2 16+512，请：
&lt;img alt="neofetch" loading="lazy" src="https://blog.razyang.com/posts/defection/2022-08-07_13.23.10.png"&gt;&lt;/p&gt;
&lt;h1 id="基本配置"&gt;基本配置&lt;/h1&gt;
&lt;h2 id="终端应用"&gt;终端应用&lt;/h2&gt;
&lt;div class="highlight"&gt;&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"&gt;&lt;code class="language-sh" data-lang="sh"&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;brew install p7zip starship rustup-init tmux go coreutils grep startship bottom zoxide fzf ripgrep shellcheck starship hugo fd 7z pandoc neofetch
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;大概先装这么多吧，zsh配置后续再迁移过来&lt;/p&gt;
&lt;h2 id="gui"&gt;GUI&lt;/h2&gt;
&lt;blockquote&gt;
&lt;p&gt;写这篇文章的时候突然恍然大悟，原来我能在这台电脑上装qq和微信，突然间一股惆怅的情绪涌上心头&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;其实也没啥好装的，浏览器暂时看看safari表现怎么样了，之后如果不成的话再装chrome。&lt;/p&gt;
&lt;p&gt;文本编辑器的话，还是当之无愧的emacs。虽然在macos上的这个版本没有native compile，但是感觉响应速度没有什么明显区别：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"&gt;&lt;code class="language-sh" data-lang="sh"&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;brew install --cask emacs
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;</description></item><item><title>Template Post</title><link>https://blog.razyang.com/posts/template-post/</link><pubDate>Thu, 04 Aug 2022 11:30:51 +0800</pubDate><guid>https://blog.razyang.com/posts/template-post/</guid><description>&lt;h1 id="segment"&gt;segment&lt;/h1&gt;
&lt;h2 id="segment-1"&gt;segment&lt;/h2&gt;
&lt;h3 id="segment-2"&gt;segment&lt;/h3&gt;
&lt;h4 id="segment-3"&gt;segment&lt;/h4&gt;
&lt;h3 id="text-style"&gt;Text style&lt;/h3&gt;
&lt;p&gt;&lt;em&gt;This text is in italics.&lt;/em&gt;
&lt;em&gt;And so is this text.&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;This text is in bold.&lt;/strong&gt;
&lt;strong&gt;And so is this text.&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;&lt;strong&gt;This text is in both.&lt;/strong&gt;&lt;/em&gt;
&lt;strong&gt;&lt;em&gt;As is this!&lt;/em&gt;&lt;/strong&gt;
&lt;em&gt;&lt;strong&gt;And this!&lt;/strong&gt;&lt;/em&gt;&lt;/p&gt;
&lt;h3 id="paragraph"&gt;Paragraph&lt;/h3&gt;
&lt;p&gt;This is a paragraph. I&amp;rsquo;m typing in a paragraph isn&amp;rsquo;t this fun?&lt;/p&gt;
&lt;p&gt;Now I&amp;rsquo;m in paragraph 2.
I&amp;rsquo;m still in paragraph 2 too!&lt;/p&gt;
&lt;p&gt;I&amp;rsquo;m in paragraph three!&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;This is a block quote. You can either
manually wrap your lines and put a &lt;code&gt;&amp;gt;&lt;/code&gt; before every line or you can let your lines get really long and wrap on their own.
It doesn&amp;rsquo;t make a difference so long as they start with a &lt;code&gt;&amp;gt;&lt;/code&gt;.&lt;/p&gt;</description></item></channel></rss>