<!doctype html><html lang=en dir=auto data-theme=dark><head><meta name=generator content="Hugo 0.152.2"><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Misc</title><meta name=description content><meta name=author content><link rel=canonical href=https://blog.razyang.com/><link crossorigin=anonymous href=/assets/css/stylesheet.343cc480b9ffc8f04ccbe5e968ad674880cab773ec19905e93033065c1e7a804.css integrity="sha256-NDzEgLn/yPBMy+XpaK1nSIDKt3PsGZBekwMwZcHnqAQ=" rel="preload stylesheet" as=style><link rel=icon href=https://blog.razyang.com/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://blog.razyang.com/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://blog.razyang.com/favicon-32x32.png><link rel=apple-touch-icon href=https://blog.razyang.com/apple-touch-icon.png><link rel=mask-icon href=https://blog.razyang.com/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate type=application/rss+xml href=https://blog.razyang.com/index.xml title=rss><link rel=alternate hreflang=en href=https://blog.razyang.com/><noscript><style>#theme-toggle,.top-link{display:none}</style></noscript><script>localStorage.getItem("pref-theme")==="light"&&(document.querySelector("html").dataset.theme="light")</script><meta property="og:url" content="https://blog.razyang.com/"><meta property="og:site_name" content="Misc"><meta property="og:title" content="Misc"><meta property="og:locale" content="en"><meta property="og:type" content="website"><meta name=twitter:card content="summary"><meta name=twitter:title content="Misc"><meta name=twitter:description content><script type=application/ld+json>{"@context":"https://schema.org","@type":"Organization","name":"Misc","url":"https://blog.razyang.com/","description":"","logo":"https://blog.razyang.com/favicon.ico","sameAs":[]}</script></head><body class=list id=top><header class=header><nav class=nav><div class=logo><a href=https://blog.razyang.com/ accesskey=h title="Misc (Alt + H)">Misc</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)" aria-label="Toggle theme">
<svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg>
<svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://blog.razyang.com/archives title=archives><span>archives</span></a></li><li><a href=https://blog.razyang.com/tags title=tags><span>tags</span></a></li></ul></nav></header><main class=main><article class="first-entry home-info"><header class=entry-header><h1>Hi</h1></header><div class=entry-content>Be Easy</div><footer class=entry-footer><div class=social-icons></div></footer></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>nixpkgs中stdenv的bootstrap过程</h2></header><div class=entry-content><p>学习nixpkgs bootstrap 这篇文章主要记录学习nixpkgs bootstrap intro这篇文章的过程，如果其中有涉及到其他博客内容，我会将相关链接贴到文章最后。
其实我对c编译器自举这个事情本来就比较感兴趣，由于c/c++的工具链相对古老，而且没有语言的包管理，语言生态都是由不同的小工具东拼西凑出来的。所以想要从头构建出一个C/C++编译器相对困难很多，但是这也是不可避免的事情。 毕竟C/C++历史悠久，即使像是go这种原生完全不依赖C生态，连标准库都不依赖libc的语言，也会有CGO的存在来复用C/C++的库。所以说当今时代的计算机领域，如果想要构建出一套自己的“软件集合”，一直向上追溯的话，GCC+glibc似乎就是一切的根源，当然clang/musl也是一种选择，但那就不是一篇文章能够覆盖的内容量了。
Overview nixpkgs是现在事实上最大的单一软件仓库（2025），可以很简单的复用已有软件。也得益于nix强制要求构建时声明构建依赖，并且自动解算运行时依赖，我们可以使用工具简单的获得特定软件包的构建和运行时依赖树：
$ nixgraph --depth=99 --out gcc_runtime_deps.png 'nixpkgs#stdenv.cc' $ nixgraph --depth=99 --out gcc_buildtime_deps.png --buildtime 'nixpkgs#stdenv.cc' 很好，运行时依赖看起来非常的合理： 然而下图是gcc的构建依赖关系(希望你有一些心理准备)：
构建依赖
stdenv 首先我们要了解一下stdenv，这个概念在nixpkgs至关重要。stdenv可以看作cc TO BE CONTINUE</p></div><footer class=entry-footer><span title='2025-11-14 09:22:11 +0800 +0800'>November 14, 2025</span>&nbsp;·&nbsp;<span>1 min</span></footer><a class=entry-link aria-label="post link to nixpkgs中stdenv的bootstrap过程" href=https://blog.razyang.com/posts/way-to-nix-2/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>也许你应该了解一下replit背后的神秘技术——nix</h2></header><div class=entry-content><p>最开始接触nix是在18年，当时参加SHLUG的每周四晚活动，偶然得知有一个名为NixOS的发行版，概念非常高大上。什么Declarative、Reproducible之类的名词虽然不是很懂，但让刚接触计算机领域没有几年的我深感震撼。不过当时我总觉得，容器技术已经很好了，非常好的解决了可复现的问题（仅限运行），只需要引如一个容器运行时，这个包含应用的迷你操作系统就可以四处被部署，简直不要太方便。
从历史讲起 不同与很多热门技术出身名门，例如go出自google，javascript出身于网景与微软的浏览器大战，rust出身于Mozilla。似乎我们现在在用的各种技术基本都“出身权贵”。不过跟这些技术领域的老大哥相比，nix有一点倒是没有掉队，那就是年龄。诞生于2003年的nix到目前为止也已经二十多岁。nix一开始并没有获得什么关注，毕竟其理念与计算机领域的事实标准相去甚远。 系统包管理 现在我们所熟知的，linux的目录结构，例如/bin/,/lib,/usr都遵循FHS标准，而这个基本结构在1995年就基本定型。在这个标准下，一个软件的不同部分被散落在文件系统的各个位置，例如可执行程序可能会被放在/usr/bin/、/usr/local/bin/、/bin/、/sbin/、/usr/sbin等等，而不同程序引用的函数库则被统一存放在另外的路径中，更别提软件还有配置文件，配置文件放在一个地方，配置文件中又包含了软件定义的各种数据文件路径、日志文件路径、资源文件路径等等。 这样以来同一个软件安装之后被大卸八块，不知道是不是称作“卸装”更为贴切。为了应对这些软件如何正确被“卸装”的问题，包管理应运而生。包管理是linux领域内老生常谈的话题了，他解决了在“这个Linux发行版的某个特定版本”中打包，分发到其他“这个Linux发行版的特定相同版本”的问题。 [TODO] 图片 很好，那现在我只需要打包就对了，是吧？可能没有那么简单，如果把软件的生命周期中的关键动作抽象为“开发”，“构建”，“分发”，“部署”的话，问题就来了： 在哪开发，在哪构建、通过什么手段分发、用什么手段以及部署在什么环境中 答案就是现实中，N种开发环境、M种构建环境、K种部署环境，如果涉及到软件依赖，则问题就更为复杂： 软件的开发依赖哪里来，构建依赖哪里来，运行时依赖哪里来 不同Linux发行版包管理中都维护了一套“没有版本冲突”的软件集合，定期发布稳定版本，后续在这套固定的软件集合中提供安全补丁以及部分包的升级服务。但真正的问题在于ubuntu 22.04中打的包，没有办法保证在ubuntu 20.04中运行，更没法保证在例如debian 10,centos 7等其他不同类型的发行版中运行。你在任何发行版中打的包，实际上隐含了一个含义，即你的软件或多或少依赖这个特定发行版的特定状态。随着时间迁移，这个发行版的软件源更新，实际上没有任何人能够保证软件还能正常编译或运行。 软件包管理 当然，很多编程语言意识到了这个问题，并在很长的历史阶段诞生了相当多的编程语言级别的包管理，甚至新的编程语言会将包管理与编译器一同分发，例如go、rust等等。这些包管理可以锁定构建依赖的版本，并通常不再采用原生的函数库与其他进程共享代码，也就不存在运行时依赖的问题，越来越多的软件选择不再通过发行版的包管理分发。但事情还是没有那么简单，主要有两点关键事实： * 很难完全避免使用外部的so库，而这些函数库通常由操作系统分发。 * “依赖”不仅仅指函数库，构建或运行时使用的外部命令，不同版本或实现也可能表现不同，例如cmake、tar等等。 第一种情况，不是没有解决方案。例如python，python语言本身被称作胶水语言，其中很多热门的包内部实际为c/C++实现，这些包的构建和分发其实面临相当大的挑战。而python的解决方案可以参考PEP 513, PEP 571, PEP 599, PEP 600, PEP 656几个标准。这些标准定义了在哪些环境构建的包、可以在哪些环境中运行。例如使用manylinux1环境构建的包，几乎可以在现在能够见到的任何linux发行版中运行，此外还有manylinux2010、manylinux2014等等，每种标准都有对应的libc和gcc版本。你可能会问，有了manylinux1，那为什么还要其他的标准呢？如果说你打算引一个近两年发布的so库版本，那自然就会知道为什么了。 而第二种情况，如果踩到坑，只能自求多福了我的朋友。 容器化！！！ 如果说上面说的系统包管理与软件包管理的割裂和历史包袱是一场慢性疾病的话，容器的出现无异于是一剂良药。容器的出现意味着可以使用比操作系统更细粒度的方式部署软件和服务，软件将自己和自己的所有依赖打包在容器镜像内，仿佛一个时间胶囊将其永久定格在一个时刻，无论何时将其拿出，都可以按照预期工作，这极大解决了软件发布和运行的问题。但很显然，时间胶囊里的机器还能正常工作，但是外部环境却可能今非西比，假如你手握Dockerfile想重新构建打包，很可能因为发行版的软件源无法工作，或某个重要依赖更新而无法不加改造的重新编译。 就差一步，就差最后一步。虽然范德彪告诉了我们，时光并不能倒流。但我们已经掌握了容器技术，只要有一种比Dockerfile更好的方式，将容器的构建依赖也定格住，似乎就完美了。 BuildPacks就是为了补齐这最后一块儿拼图而做出的努力，其主打的概念就是“从源码直接构建为容器镜像”，似乎可以绕过操作系统直接构建容器镜像了？事实并不是这样的，BuildPacks实际上封装的是语言级别的包管理，所有你需要使用操作系统包管理额外做的事情，在实际场景中，你仍需要编写Dockerfile来构建容器。当然，除非为所有软件的每个版本都单独构建容器镜像并且归档，以后容器取代进程成为操作系统最小调度单位，例如执行一个ls命令，实际上执行的是ls程序以及所有依赖组成的容器。虽然这听起来很夸张，但像是ClearOS，Fedora SilverBlue真的有向这个方向努力，虽然结果似乎不太理想。 可组合性的缺失 TO BE CONTINUE</p></div><footer class=entry-footer><span title='2025-11-01 19:12:11 +0800 +0800'>November 1, 2025</span>&nbsp;·&nbsp;<span>1 min</span></footer><a class=entry-link aria-label="post link to 也许你应该了解一下replit背后的神秘技术——nix" href=https://blog.razyang.com/posts/way-to-nix-3/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>Nix and Content Address</h2></header><div class=entry-content><p>Nix目前的构建和发布模型 derivation outputs and output paths Nix软件构建以Derivation为核心，Derivation有以下核心属性：
Derivation表示了软件的构建过程； Derivation可以依赖其他Derivation； Derivation执行后具有副作用，会在/nix/store下生成路径为xxx-name.drv的文件，其中xxx为该Derivation的唯一标识符，在任何电脑中都一致； xxx-name.drv可以被进一步构建成产物，并且产物的路径存储在xxx-name.drv中，在构建前就可以知道，此处我们称为outPath； outPath路径中也存在唯一标识，同一个Derrvation产生的.drv文件中的outPath一定相同； 由于构建前就知道产物路径，引用某个derivation时，只要检查其中存储的outPath存不存在，就可以判定需不需要重复编译； 不同机器可以通过共享outPath来共享构建缓存； 这里存在两个目录，一个是.drv的目录，一个是outPath的目录，两者的路径中都有唯一标识符，且路径都根据Derivation的参数计算得来，outPath存储在.drv中。
构建过程 nix包管理的软件构建过程用伪码表示大致如下:
derivation = getDerivationFrom(nixpkgs, package_name) drv = derivatoin() # 此处存在副作用，derivation函数调用后会生成.drv文件 if checkOutPathExist(drv.outPath): pass # 如果产物目录已经存在，就不用重复构建了 else: drv.build() # drv.build()会将软件构建后放到drv.outPath中 binary cache引入后:
derivation = getDerivationFrom(nixpkgs, package_name) drv = derivatoin() if checkOutPathExist(drv.outPath): pass else: if fetchOutPathFromBinaryCache(drv.outPath): pass # 尝试从BinaryCache服务器中下载对应的包，放到outPath中 else: drv.build() Input-Address Model 总体来说，上面我们描述的目前Nix的做法是将软件构建软件的过程（包括输入）抽象为一个哈希值，这个唯一哈希值可以代表软件的某个特定状态，然后用这个哈希值来索引构建后的软件。
在构建过程当中，任何输入的改变必然会导致输出的路径发生变化： 过度重复构建 你可能已经意识到了一些不对，在正常的软件构建过程当中，输入的改变不一定会导致输出不同，比如说代码路径下面增加了一些文档，或者说构建流程发生了改变。
然而在Nix目前的构建模型中，输入的任何变化都会导致输出路径的变化，但现实当中这样往往会导致一些不好的副作用。
例如go语言的源码中使用perl来做代码单元测试，原则上来说，使用什么版本的perl做单元测试，或者是否做单元测试，都不会改变构建产物。我们可以认为，源码中不是所有改动都会影响产物。但在nix中，如果perl包发生了改变，而go又依赖perl做单元测试，那么go的产物路径就会发生变化，进而需要重新编译。再进一步，所有依赖go的包也需要重新编译，导致了很多没有必要的重复编译。
Content-Address Model 解决上述问题的方式思路也很简单，就是使用content address的方式来确定构建缓存的实际目录。
所谓content address，与input address相对。在input address的模型中，用于索引value的key与value内容无关； 但在content address的模型中，用于索引value的key是根据value的内容计算得来。content address最简单的例子就是使用文件的哈希值来索引文件，给定文件的哈希值，返回文件内容； 而input address典型例子就是给定文件的文件名，返回文件的内容；
...</p></div><footer class=entry-footer><span title='2023-12-08 16:34:44 +0800 +0800'>December 8, 2023</span>&nbsp;·&nbsp;<span>1 min</span></footer><a class=entry-link aria-label="post link to Nix and Content Address" href=https://blog.razyang.com/posts/nix-and-content-address/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>Way to Nix 1</h2></header><div class=entry-content><p>最近学习了一些Nix相关的东西，把家里大多数机器都切到了nixos上，感觉很不错。但是由于nix文档比较差，写自己配置的时候，很多时候需要看代码，或者抄别人的配置一点点凑，过程当中遇到了不少问题。也学习了不少Nix的基本概念，于是记录一下相关的概念和技术以免忘记。
前阵子看过NickCao的前些年的一个视频，非常有条例的介绍了一些nix的基本概念，有兴趣可以去看一下：【金枪鱼之夜：Nix - 从构建系统到配置管理-哔哩哔哩】
Nix as a build systems 构建系统一般就是指从源码生成产物的一套工具生态集合，就拿Makefile举例，几乎所有的构建过程都可以描述成如下形式的嵌套结构：
构建目标: 构建原料 构建过程 围绕着gnu make，有一套完整的，有着悠久历史的构建系统，如GNU Autoconf，Cmake等，许多现代语言也包含了自己的构建系统，如rust的cargo，go的build，js的npm等等。也会有许多项目选择多种构建系统嵌套，如Cmake生成makefile调用Cargo来进行项目构建。
Derivation 也许nix里最重要的概念就是Derivation了，它与nix中的很多概念相互关联，并作为纽带。可以说理解了Derivation，至少就理解了Nix的半壁江山。
首先， derivition是nix中的一个内置函数,代码实现位于(https://github.com/NixOS/nix/blob/188c803ddb5e63b243ddb84eba9b70e45475b7ea/src/libexpr/primops/derivation.nix#L2)，实际调用的是内部C++函数prim_derivationStrict:
nix-repl> derivation «lambda @ /builtin/derivation.nix:5:1» 与其他构建系统类似，derivation包含了构建原料，构建目标以及构建过程，调用这个函数必须有name、system以及builder三个必选参数，其他可选参数可参考Nix Reference Manual:
nix-repl> derivation {name = "target_name";system="x86_64-linux"; builder="builder_binary";} «derivation /nix/store/6z9jj5khn7j3xi2fv8fibpzj6gnq4iz4-target_name.drv» 值得注意的是，derivation函数存在一个副作用，即在/nix/store/目录下生成一个以.drv为后缀的文件，并且文件名中包含了一个类似哈希的字符串，保证路径的唯一性。derivation有如下属性:
同样参数的derivation函数调用后生成的文件，路径一定是一样的（在哈希算法的保证下，可以假定不同参数调用derivation产生的drv文件路径一定是不同的） derivation中包含的所有参数必须为字面量，或预先可以确定哈希值的固定内容（Fixed-Output Derivations） derivation可以互相依赖，一个derivation可以依赖另外一个derivation derivation可以被执行，类似Makefile一样可以被构建 derivation会被在隔离的环境执行，其中没有类似/bin/bash之类可以预先假定存在的路径，能且只能通过derivation依赖的方式在构建过程当中引入其他软件 derivation执行后会产生两个关键参数，out.out以及out.outPath，一个存储了drv的路径，一个存储了构建产物的路径 nix-repl> d = derivation {name = "target_name";system="x86_64-linux"; builder="builder_binary";} nix-repl> d.out.out «derivation /nix/store/6z9jj5khn7j3xi2fv8fibpzj6gnq4iz4-target_name.drv» nix-repl> d.out.outPath "/nix/store/pd5l9rzb613v5lv4c6q2m0c81zd9w3l6-target_name" nix-repl> d.out.out == d true nix-repl> d.out == d true 以上属性组合的结果，使得nix构建系统存在如下特性：
任何软件的derivation在/nix/store中的路径包含了唯一哈希值，这个路径实际上代表了产物是用何种输入源，以何种构建方式，配置何种构建参数所构建出来的结果，且由于derivation之间互相依赖，整颗依赖树的任何一个环节发生了变化，重新构建后，derivation路径相应也会发生变化 derivation既可以描述软件的构建过程，又可以描述多种软件组合称为操作系统的过程，进一步说，如果把操作系统当成目标产物，通过derivation的嵌套，nix可以描述出整个操作系统的构建过程，且在保证可完全可复现。 Nix as programing language 与其他构建系统采用的语法风格不同的是，Nix采用了函数式语法，且没有类型系统，这也是Nix看起来比较吓人的主要原因
...</p></div><footer class=entry-footer><span title='2023-12-01 11:56:15 +0800 +0800'>December 1, 2023</span>&nbsp;·&nbsp;<span>2 min</span></footer><a class=entry-link aria-label="post link to Way to Nix 1" href=https://blog.razyang.com/posts/way-to-nix-1/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>叛逃</h2></header><div class=entry-content><p>所谓叛逃 仔细想一想，自从上大学开始，我用linux做为日常工作和学习的系统也有将近六年了。 这六年来，常见的Linux发行版基本都装了个遍，常见的桌面环境和窗口管理器也基本用了个遍。 不过随着时间流逝，我逐渐发现，桌面环境折腾无数遍，其实实际在用的图形界面软件只有三个：emacs、chrome、alacritty。
更抽象一点的话，其实就是一个编辑器，一个浏览器还有一个终端模拟器。其他软件使用频率都非常低，最近两年内，我逐渐发现自己打开文件管理器的频率也越来越低，以至于文件管理器对于我日常的电脑使用来说，也成为了一个没有必要的软件。
铺垫了这么多，其实我就是想说，爷叛逃了，到MacOS。
目的地 其实也没啥道理，最近想买一个笔记本，看了一圈。intel 11代摆大烂，12代功耗爆炸；AMD 6000系的笔记本，续航稍微好一些，但GPU硬件设计有问题。仔细想了一想，苹果的笔记本成了这两年唯一没重大问题，没开过什么倒车的设备了。
所以，Macbook Air m2 16+512，请： 基本配置 终端应用 brew install p7zip starship rustup-init tmux go coreutils grep startship bottom zoxide fzf ripgrep shellcheck starship hugo fd 7z pandoc neofetch 大概先装这么多吧，zsh配置后续再迁移过来
GUI 写这篇文章的时候突然恍然大悟，原来我能在这台电脑上装qq和微信，突然间一股惆怅的情绪涌上心头
其实也没啥好装的，浏览器暂时看看safari表现怎么样了，之后如果不成的话再装chrome。
文本编辑器的话，还是当之无愧的emacs。虽然在macos上的这个版本没有native compile，但是感觉响应速度没有什么明显区别：
brew install --cask emacs</p></div><footer class=entry-footer><span title='2022-08-07 12:52:43 +0800 +0800'>August 7, 2022</span>&nbsp;·&nbsp;<span>1 min</span></footer><a class=entry-link aria-label="post link to 叛逃" href=https://blog.razyang.com/posts/defection/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>Template Post</h2></header><div class=entry-content><p>segment segment segment segment Text style This text is in italics. And so is this text.
This text is in bold. And so is this text.
This text is in both. As is this! And this!
Paragraph This is a paragraph. I’m typing in a paragraph isn’t this fun?
Now I’m in paragraph 2. I’m still in paragraph 2 too!
I’m in paragraph three!
This is a block quote. You can either manually wrap your lines and put a > before every line or you can let your lines get really long and wrap on their own. It doesn’t make a difference so long as they start with a >.
...</p></div><footer class=entry-footer><span title='2022-08-04 11:30:51 +0800 +0800'>August 4, 2022</span>&nbsp;·&nbsp;<span>1 min</span></footer><a class=entry-link aria-label="post link to Template Post" href=https://blog.razyang.com/posts/template-post/></a></article></main><footer class=footer><span>&copy; 2025 <a href=https://blog.razyang.com/>Misc</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
<a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentColor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");if(menu){const e=localStorage.getItem("menu-scroll-position");e&&(menu.scrollLeft=parseInt(e,10)),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}}document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{const e=document.querySelector("html");e.dataset.theme==="dark"?(e.dataset.theme="light",localStorage.setItem("pref-theme","light")):(e.dataset.theme="dark",localStorage.setItem("pref-theme","dark"))})</script></body></html>