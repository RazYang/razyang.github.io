---
title: "也许你应该了解一下replit背后的神秘技术——nix"
date: 2025-11-01T19:12:11+08:00
draft: true
---

最开始接触nix是在18年，当时参加SHLUG的每周四晚活动，偶然得知有一个名为NixOS的发行版，概念非常高大上。什么Declarative、Reproducible之类的名词虽然不是很懂，但让刚接触计算机领域没有几年的我深感震撼。不过当时我总觉得，容器技术已经很好了，非常好的解决了可复现的问题（仅限运行），只需要引如一个容器运行时，这个包含应用的迷你操作系统就可以四处被部署，简直不要太方便。

# 从历史讲起
不同与很多热门技术出身名门，例如go出自google，javascript出身于网景与微软的浏览器大战，rust出身于Mozilla。似乎我们现在在用的各种技术基本都“出身权贵”。不过跟这些技术领域的老大哥相比，nix有一点倒是没有掉队，那就是年龄。诞生于2003年的nix到目前为止也已经二十多岁。nix一开始并没有获得什么关注，毕竟其理念与计算机领域的事实标准相去甚远。

## 系统包管理

现在我们所熟知的，linux的目录结构，例如/bin/,/lib,/usr都遵循FHS标准，而这个基本结构在1995年就基本定型。在这个标准下，一个软件的不同部分被散落在文件系统的各个位置，例如可执行程序可能会被放在/usr/bin/、/usr/local/bin/、/bin/、/sbin/、/usr/sbin等等，而不同程序引用的函数库则被统一存放在另外的路径中，更别提软件还有配置文件，配置文件放在一个地方，配置文件中又包含了软件定义的各种数据文件路径、日志文件路径、资源文件路径等等。


这样以来同一个软件安装之后被大卸八块，不知道是不是称作“卸装”更为贴切。为了应对这些软件如何正确被“卸装”的问题，包管理应运而生。包管理是linux领域内老生常谈的话题了，他解决了在“这个Linux发行版的某个特定版本”中打包，分发到其他“这个Linux发行版的特定相同版本”的问题。
    

[TODO] 图片
    

很好，那现在我只需要打包就对了，是吧？可能没有那么简单，如果把软件的生命周期中的关键动作抽象为“开发”，“构建”，“分发”，“部署”的话，问题就来了：


在哪开发，在哪构建、通过什么手段分发、用什么手段以及部署在什么环境中
    
    
答案就是现实中，N种开发环境、M种构建环境、K种部署环境，如果涉及到软件依赖，则问题就更为复杂：
    

软件的开发依赖哪里来，构建依赖哪里来，运行时依赖哪里来


不同Linux发行版包管理中都维护了一套“没有版本冲突”的软件集合，定期发布稳定版本，后续在这套固定的软件集合中提供安全补丁以及部分包的升级服务。但真正的问题在于ubuntu 22.04中打的包，没有办法保证在ubuntu 20.04中运行，更没法保证在例如debian 10,centos 7等其他不同类型的发行版中运行。你在任何发行版中打的包，实际上隐含了一个含义，即你的软件或多或少依赖这个特定发行版的特定状态。随着时间迁移，这个发行版的软件源更新，实际上没有任何人能够保证软件还能正常编译或运行。

## 软件包管理
当然，很多编程语言意识到了这个问题，并在很长的历史阶段诞生了相当多的编程语言级别的包管理，甚至新的编程语言会将包管理与编译器一同分发，例如go、rust等等。这些包管理可以锁定构建依赖的版本，并通常不再采用原生的函数库与其他进程共享代码，也就不存在运行时依赖的问题，越来越多的软件选择不再通过发行版的包管理分发。但事情还是没有那么简单，主要有两点关键事实：
    * 很难完全避免使用外部的so库，而这些函数库通常由操作系统分发。
    * “依赖”不仅仅指函数库，构建或运行时使用的外部命令，不同版本或实现也可能表现不同，例如cmake、tar等等。
第一种情况，不是没有解决方案。例如python，python语言本身被称作胶水语言，其中很多热门的包内部实际为c/C++实现，这些包的构建和分发其实面临相当大的挑战。而python的解决方案可以参考PEP 513, PEP 571, PEP 599,  PEP 600, PEP 656几个标准。这些标准定义了在哪些环境构建的包、可以在哪些环境中运行。例如使用manylinux1环境构建的包，几乎可以在现在能够见到的任何linux发行版中运行，此外还有manylinux2010、manylinux2014等等，每种标准都有对应的libc和gcc版本。你可能会问，有了manylinux1，那为什么还要其他的标准呢？如果说你打算引一个近两年发布的so库版本，那自然就会知道为什么了。


    而第二种情况，如果踩到坑，只能自求多福了我的朋友。

## 容器化！！！
如果说上面说的系统包管理与软件包管理的割裂和历史包袱是一场慢性疾病的话，容器的出现无异于是一剂良药。容器的出现意味着可以使用比操作系统更细粒度的方式部署软件和服务，软件将自己和自己的所有依赖打包在容器镜像内，仿佛一个时间胶囊将其永久定格在一个时刻，无论何时将其拿出，都可以按照预期工作，这极大解决了软件发布和运行的问题。但很显然，时间胶囊里的机器还能正常工作，但是外部环境却可能今非西比，假如你手握Dockerfile想重新构建打包，很可能因为发行版的软件源无法工作，或某个重要依赖更新而无法不加改造的重新编译。


就差一步，就差最后一步。虽然范德彪告诉了我们，时光并不能倒流。但我们已经掌握了容器技术，只要有一种比Dockerfile更好的方式，将容器的构建依赖也定格住，似乎就完美了。


BuildPacks就是为了补齐这最后一块儿拼图而做出的努力，其主打的概念就是“从源码直接构建为容器镜像”，似乎可以绕过操作系统直接构建容器镜像了？事实并不是这样的，BuildPacks实际上封装的是语言级别的包管理，所有你需要使用操作系统包管理额外做的事情，在实际场景中，你仍需要编写Dockerfile来构建容器。当然，除非为所有软件的每个版本都单独构建容器镜像并且归档，以后容器取代进程成为操作系统最小调度单位，例如执行一个ls命令，实际上执行的是ls程序以及所有依赖组成的容器。虽然这听起来很夸张，但像是ClearOS，Fedora SilverBlue真的有向这个方向努力，虽然结果似乎不太理想。

# 可组合性的缺失
    
# TO BE CONTINUE
