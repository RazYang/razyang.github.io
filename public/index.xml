<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Misc</title>
    <link>https://blog.razyang.com/</link>
    <description>Recent content on Misc</description>
    <generator>Hugo</generator>
    <language>en</language>
    <lastBuildDate>Sat, 22 Nov 2025 15:09:04 +0800</lastBuildDate>
    <atom:link href="https://blog.razyang.com/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>[0x01]：nix之路——究极构建系统</title>
      <link>https://blog.razyang.com/posts/nix1/</link>
      <pubDate>Sat, 22 Nov 2025 15:09:04 +0800</pubDate>
      <guid>https://blog.razyang.com/posts/nix1/</guid>
      <description>&lt;h1 id=&#34;构建的本质&#34;&gt;构建的本质&lt;/h1&gt;&#xA;&lt;p&gt;让我们先忘掉nix，假设我们现在要设计一个究极的构建系统，能构建计算机领域的任何东西。为了实现这个伟大的目标，我们首先要思考一下，什么是“构建”&lt;/p&gt;&#xA;&lt;p&gt;拿最简单的hello world举例。我们写完了hello world的源码，这个源码是如何变为产物的？&lt;/p&gt;&#xA;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;$ gcc hello.c -o hello&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;似乎很简单，只要有一个源码，有一个构建工具，就可以输出最终产物:&lt;/p&gt;&#xA;&lt;p&gt;&lt;img src=&#34;easy_one.svg&#34; alt=&#34;easy_one&#34;&gt;&lt;/p&gt;&#xA;&lt;p&gt;ELF是构建产物，那压缩包呢？似乎也是一个道理，只不过构建依赖中有压缩工具而已&lt;/p&gt;&#xA;&lt;p&gt;压缩包是构建产物，那容器镜像呢？好像也一样，无非也就是多引入几个工具，里面包含一个rootfs，生成一个特殊格式的压缩包而已&lt;/p&gt;&#xA;&lt;p&gt;容器镜像是构建产物，操作系统呢？好像也差不多，只不过是依赖多了一些。&lt;/p&gt;&#xA;&lt;p&gt;可以说掌握了构建的本质，就掌握了能够构建所有东西的理论基础&lt;/p&gt;&#xA;&lt;h1 id=&#34;hello-world&#34;&gt;hello world!&lt;/h1&gt;&#xA;&lt;p&gt;你可能说，问题才没那么简单！让我们拿最简单的hello world程序举例&lt;/p&gt;&#xA;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-c&#34; data-lang=&#34;c&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;#include&lt;/span&gt; &lt;span style=&#34;color:#75715e&#34;&gt;&amp;lt;stdio.h&amp;gt;&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;main&lt;/span&gt;() {&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#a6e22e&#34;&gt;printf&lt;/span&gt;(&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;hello world&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;\n&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;&lt;/span&gt;);&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;}&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;stdio.h哪里来呢，这个应该算作什么呢？然后我们看一下hello的动态链接情况&lt;/p&gt;&#xA;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;$ ldd hello&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        linux-vdso.so.1 &lt;span style=&#34;color:#f92672&#34;&gt;(&lt;/span&gt;0x00007ffcda3d9000&lt;span style=&#34;color:#f92672&#34;&gt;)&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        libc.so.6 &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt;&amp;gt; /lib64/libc.so.6 &lt;span style=&#34;color:#f92672&#34;&gt;(&lt;/span&gt;0x00007b5716402000&lt;span style=&#34;color:#f92672&#34;&gt;)&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        /lib64/ld-linux-x86-64.so.2 &lt;span style=&#34;color:#f92672&#34;&gt;(&lt;/span&gt;0x00007b5716606000&lt;span style=&#34;color:#f92672&#34;&gt;)&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;libc.so.6以及ld-linux-x86-64.so.2算作什么呢？似乎不只运行阶段，我们构建的时候也需要这些文件&lt;/p&gt;&#xA;&lt;p&gt;好好好，让我们弥补一下：&lt;/p&gt;&#xA;&lt;p&gt;&lt;img src=&#34;complex_one.svg&#34; alt=&#34;complex_one&#34;&gt;&lt;/p&gt;&#xA;&lt;p&gt;在上面这张图中，我将gcc也算作了构建依赖，使用bash脚本作为构建器，其中可能使用mkdir之类的命令，所以说可能也需要coreutils作为构建依赖，实际问题可能会更复杂，但总体来说都能总结为（源码+依赖 -&amp;gt; 产物）&lt;/p&gt;&#xA;&lt;h1 id=&#34;究极的构建系统&#34;&gt;究极的构建系统&lt;/h1&gt;&#xA;&lt;p&gt;很好，很好，很好。现在我们既理解了构建的本质，也有了hello world的实际例子，理论与实践相结合，现在离目标的“究极构建系统”就差一个程序员了。&lt;/p&gt;&#xA;&lt;h2 id=&#34;meta-builder-v001&#34;&gt;Meta Builder (v0.0.1)&lt;/h2&gt;&#xA;&lt;p&gt;实现似乎也很简单，把构建过程封装成一个函数，成果物就是函数的返回值：&lt;/p&gt;&#xA;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-go&#34; data-lang=&#34;go&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;// ...&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;seed&lt;/span&gt; = &lt;span style=&#34;color:#a6e22e&#34;&gt;downloadUrl&lt;/span&gt;(&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;https://example.com/bootstrap-seed.tar.gz&amp;#34;&lt;/span&gt;)&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;(&lt;span style=&#34;color:#a6e22e&#34;&gt;gcc&lt;/span&gt;,&lt;span style=&#34;color:#a6e22e&#34;&gt;make&lt;/span&gt;,&lt;span style=&#34;color:#a6e22e&#34;&gt;glibc&lt;/span&gt;,&lt;span style=&#34;color:#a6e22e&#34;&gt;autoconf&lt;/span&gt;,&lt;span style=&#34;color:#a6e22e&#34;&gt;m4&lt;/span&gt;,&lt;span style=&#34;color:#a6e22e&#34;&gt;bash&lt;/span&gt;,&lt;span style=&#34;color:#a6e22e&#34;&gt;coreutils&lt;/span&gt;) &lt;span style=&#34;color:#f92672&#34;&gt;:=&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;mkPackage&lt;/span&gt;(&lt;span style=&#34;color:#a6e22e&#34;&gt;seed&lt;/span&gt;)&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;// 源码来源无所谓，只要能返回值类型一致就可以&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;hello_src&lt;/span&gt; = &lt;span style=&#34;color:#a6e22e&#34;&gt;downloadUrl&lt;/span&gt;(&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;mirror://gnu/hello/hello-2.12.2.tar.gz&amp;#34;&lt;/span&gt;)&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;hello&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;:=&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;mkPackage&lt;/span&gt;(&lt;span style=&#34;color:#a6e22e&#34;&gt;hello_src&lt;/span&gt;,&lt;span style=&#34;color:#a6e22e&#34;&gt;gcc&lt;/span&gt;,&lt;span style=&#34;color:#a6e22e&#34;&gt;bash&lt;/span&gt;,&lt;span style=&#34;color:#a6e22e&#34;&gt;coreutils&lt;/span&gt;,&lt;span style=&#34;color:#a6e22e&#34;&gt;make&lt;/span&gt;,&lt;span style=&#34;color:#a6e22e&#34;&gt;autoconf&lt;/span&gt;)&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;// 当然，动态链接库依赖也没问题&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;libanything_src&lt;/span&gt; = &lt;span style=&#34;color:#a6e22e&#34;&gt;downloadUrl&lt;/span&gt;(&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;...&amp;#34;&lt;/span&gt;)&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;libanything&lt;/span&gt; = &lt;span style=&#34;color:#a6e22e&#34;&gt;mkPackage&lt;/span&gt;(&lt;span style=&#34;color:#a6e22e&#34;&gt;libanything_src&lt;/span&gt;,&lt;span style=&#34;color:#f92672&#34;&gt;...&lt;/span&gt;)&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;anything_src&lt;/span&gt; = &lt;span style=&#34;color:#a6e22e&#34;&gt;downloadUrl&lt;/span&gt;(&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;...&amp;#34;&lt;/span&gt;)&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;anything&lt;/span&gt; = &lt;span style=&#34;color:#a6e22e&#34;&gt;mkPackage&lt;/span&gt;(&lt;span style=&#34;color:#a6e22e&#34;&gt;anything_src&lt;/span&gt;,&lt;span style=&#34;color:#a6e22e&#34;&gt;libanything&lt;/span&gt;,&lt;span style=&#34;color:#f92672&#34;&gt;...&lt;/span&gt;)&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;// 究极构建系统，当然要可以自举了&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;bootstrap_seed&lt;/span&gt; = &lt;span style=&#34;color:#a6e22e&#34;&gt;mkPackage&lt;/span&gt;(&lt;span style=&#34;color:#f92672&#34;&gt;...&lt;/span&gt;)&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;以上代码描绘了这样一套系统：&lt;/p&gt;</description>
    </item>
    <item>
      <title>[0x00]：nix之路——为什么我要学习nix</title>
      <link>https://blog.razyang.com/posts/nix0/</link>
      <pubDate>Sat, 22 Nov 2025 14:24:11 +0800</pubDate>
      <guid>https://blog.razyang.com/posts/nix0/</guid>
      <description>&lt;h1 id=&#34;为什么我要学习nix&#34;&gt;为什么我要学习nix&lt;/h1&gt;&#xA;&lt;p&gt;还记得大学开学拿到自己第一台笔记本电脑时候，当时兴高采烈的打算装上visual studio开始探索计算机世界，但反反复复失败之后，我最后决定把windows干掉安装linux。 接下来，一台笔记本，一个Linux系统的配置就伴随了我整个大学时光。&lt;/p&gt;&#xA;&lt;p&gt;当然，在使用期间免不了喜欢配置各种桌面系统、探索各种命令行软件、重装各种发行版。常见的比如ubuntu、fedora、archlinux、opensuse、Elementary OS，还有少见一点的例如Qubes OS、clear os、fedora silverblue，可以说各式各样的发行版都玩过一遍。&lt;/p&gt;&#xA;&lt;p&gt;整个过程下来，我逐渐感受到，不同发行版之间的区别，无非也就是包管理的区别和其中维护的包集合数量/质量之间的区别。&lt;/p&gt;&#xA;&lt;p&gt;然而在当时尝试的众多发行版中，有这样一个发行版，每次都让我望而却步，却又充满了好奇，那就是nixos。nixos很不一样，他用的nix包管理与其说是一个包管理，不如说是一个终极的构建工具，而nixos恰好是nix打出来的一种产物而已。&lt;/p&gt;&#xA;&lt;p&gt;虽然现在nix的github主页的介绍中写着&amp;quot;Nix, the purely functional package manager&amp;quot;，不过我觉得这个介绍可能过于狭隘，最开始Eelco Dolstra的论文题目是&amp;quot;The Purely Functional Software Deployment Model&amp;quot;，两个表述之间，孰强孰弱立马见分晓。&lt;/p&gt;&#xA;&lt;p&gt;不过就像我前面所说，当时我只是知道有这么一个神奇的发行版，使用非FHS的目录结构，其他什么“可重现”，“原子升级”，“声明式”之类词汇虽然挺起来高大上，但是这和我又有什么关系呢？毕竟这是一个正常ELF文件都没办法在上面跑的操作系统。&lt;/p&gt;&#xA;&lt;p&gt;若干年后，在我经历了各种交叉编译、静态链接、各种操作系统适配问题、容器镜像构建问题之后，我一步一步的走向nix。并且笃定的认为nix正在成为计算机领域的下一代构建技术，并且将会杀死发行版这个概念。&lt;/p&gt;&#xA;&lt;p&gt;对于我来说，学习nix的过程从来不是容易的。在2018年左右，我第一次尝试安装nixos，当时觉得自己连archlinux安装都没什么问题，无非也就是照着官网的文档一步一步来，但很快我就发现，在nixos中似乎常规的linux技巧都失效了，一切都被一个巨大的配置文档所支配，我完全无法理解背后到底发生了什么。&lt;/p&gt;&#xA;&lt;p&gt;后来，尝试去读nix pills文档，读Eelco Dolstra的论文，尝试理解nix的基本概念，但也一知半解。再后来nix推出了flake，虽然我一向喜欢一些高概念的事物，但是nix相关的概念之复杂，最开始真的让我无从下手。然而这一切直到我开始阅读nixpkgs代码，以及一点一点开始编写nix代码之后才缓解，终于能将各种基本概念映射到实际了。&lt;/p&gt;&#xA;&lt;p&gt;而这个系列（如果顺利的话），将介绍nix的一些基本概念，后续可能还会加上一些基本的使用场景和使用技巧，帮助还没有接触nix或者已经接触nix但对其原理还不太清楚的人更快的进入nix的领域。我希望通过这个系列文章能够让你认识到nix的本质，或者说让你更接近nix的本质，而不是被表面上眼花缭乱的封装搞得晕头转向，就像我最开始了解nix时的那样。&lt;/p&gt;</description>
    </item>
    <item>
      <title>Nix and Content Address</title>
      <link>https://blog.razyang.com/posts/nix-and-content-address/</link>
      <pubDate>Fri, 08 Dec 2023 16:34:44 +0800</pubDate>
      <guid>https://blog.razyang.com/posts/nix-and-content-address/</guid>
      <description>&lt;h1 id=&#34;nix目前的构建和发布模型&#34;&gt;Nix目前的构建和发布模型&lt;/h1&gt;&#xA;&lt;h2 id=&#34;derivation-outputs-and-output-paths&#34;&gt;&lt;code&gt;derivation outputs&lt;/code&gt; and &lt;code&gt;output paths&lt;/code&gt;&lt;/h2&gt;&#xA;&lt;p&gt;Nix软件构建以Derivation为核心，Derivation有以下核心属性：&lt;/p&gt;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;Derivation表示了软件的构建过程；&lt;/li&gt;&#xA;&lt;li&gt;Derivation可以依赖其他Derivation；&lt;/li&gt;&#xA;&lt;li&gt;Derivation执行后具有副作用，会在&lt;code&gt;/nix/store&lt;/code&gt;下生成路径为&lt;code&gt;xxx-name.drv&lt;/code&gt;的文件，其中xxx为该Derivation的唯一标识符，在任何电脑中都一致；&lt;/li&gt;&#xA;&lt;li&gt;&lt;code&gt;xxx-name.drv&lt;/code&gt;可以被进一步构建成产物，并且产物的路径存储在&lt;code&gt;xxx-name.drv&lt;/code&gt;中，在构建前就可以知道，此处我们称为&lt;code&gt;outPath&lt;/code&gt;；&lt;/li&gt;&#xA;&lt;li&gt;&lt;code&gt;outPath&lt;/code&gt;路径中也存在唯一标识，同一个Derrvation产生的&lt;code&gt;.drv&lt;/code&gt;文件中的&lt;code&gt;outPath&lt;/code&gt;一定相同；&lt;/li&gt;&#xA;&lt;li&gt;由于构建前就知道产物路径，引用某个derivation时，只要检查其中存储的&lt;code&gt;outPath&lt;/code&gt;存不存在，就可以判定需不需要重复编译；&lt;/li&gt;&#xA;&lt;li&gt;不同机器可以通过共享&lt;code&gt;outPath&lt;/code&gt;来共享构建缓存；&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&lt;blockquote&gt;&#xA;&lt;blockquote&gt;&#xA;&lt;p&gt;这里存在两个目录，一个是&lt;code&gt;.drv&lt;/code&gt;的目录，一个是&lt;code&gt;outPath&lt;/code&gt;的目录，两者的路径中都有唯一标识符，且路径都根据Derivation的参数计算得来，&lt;code&gt;outPath&lt;/code&gt;存储在&lt;code&gt;.drv&lt;/code&gt;中。&lt;/p&gt;&#xA;&lt;/blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&lt;h2 id=&#34;构建过程&#34;&gt;构建过程&lt;/h2&gt;&#xA;&lt;p&gt;nix包管理的软件构建过程用伪码表示大致如下:&lt;/p&gt;&#xA;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-python&#34; data-lang=&#34;python&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;derivation &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; getDerivationFrom(nixpkgs, package_name)&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;drv &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; derivatoin()      &lt;span style=&#34;color:#75715e&#34;&gt;# 此处存在副作用，derivation函数调用后会生成.drv文件&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; checkOutPathExist(drv&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;outPath):&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;pass&lt;/span&gt;                &lt;span style=&#34;color:#75715e&#34;&gt;# 如果产物目录已经存在，就不用重复构建了&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;else&lt;/span&gt;:&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    drv&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;build()         &lt;span style=&#34;color:#75715e&#34;&gt;# drv.build()会将软件构建后放到drv.outPath中&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;binary cache引入后:&lt;/p&gt;&#xA;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-python&#34; data-lang=&#34;python&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;derivation &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; getDerivationFrom(nixpkgs, package_name)&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;drv &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; derivatoin()&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; checkOutPathExist(drv&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;outPath):&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;pass&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;else&lt;/span&gt;:&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; fetchOutPathFromBinaryCache(drv&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;outPath):&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#66d9ef&#34;&gt;pass&lt;/span&gt;        &lt;span style=&#34;color:#75715e&#34;&gt;# 尝试从BinaryCache服务器中下载对应的包，放到outPath中&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;else&lt;/span&gt;:&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        drv&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;build()&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h1 id=&#34;input-address-model&#34;&gt;Input-Address Model&lt;/h1&gt;&#xA;&lt;p&gt;总体来说，上面我们描述的目前Nix的做法是将软件构建软件的过程（包括输入）抽象为一个哈希值，这个唯一哈希值可以代表软件的某个特定状态，然后用这个哈希值来索引构建后的软件。&lt;/p&gt;&#xA;&lt;p&gt;在构建过程当中，任何输入的改变必然会导致输出的路径发生变化：&#xA;&lt;img src=&#34;input_address.svg&#34; alt=&#34;input address model&#34;&gt;&#xA;&lt;img src=&#34;input_address_dependencies_change.svg&#34; alt=&#34;input address model&#34;&gt;&lt;/p&gt;&#xA;&lt;h2 id=&#34;过度重复构建&#34;&gt;过度重复构建&lt;/h2&gt;&#xA;&lt;p&gt;你可能已经意识到了一些不对，在正常的软件构建过程当中，输入的改变不一定会导致输出不同，比如说代码路径下面增加了一些文档，或者说构建流程发生了改变。&lt;/p&gt;&#xA;&lt;p&gt;然而在Nix目前的构建模型中，输入的任何变化都会导致输出路径的变化，但现实当中这样往往会导致一些不好的副作用。&lt;/p&gt;&#xA;&lt;p&gt;例如go语言的源码中使用perl来做代码单元测试，原则上来说，使用什么版本的perl做单元测试，或者是否做单元测试，都不会改变构建产物。我们可以认为，源码中不是所有改动都会影响产物。但在nix中，如果perl包发生了改变，而go又依赖perl做单元测试，那么go的产物路径就会发生变化，进而需要重新编译。再进一步，所有依赖go的包也需要重新编译，导致了很多没有必要的重复编译。&lt;/p&gt;&#xA;&lt;h1 id=&#34;content-address-model&#34;&gt;Content-Address Model&lt;/h1&gt;&#xA;&lt;p&gt;解决上述问题的方式思路也很简单，就是使用content address的方式来确定构建缓存的实际目录。&lt;/p&gt;&#xA;&lt;p&gt;所谓content address，与input address相对。在input address的模型中，用于索引value的key与value内容无关；&#xA;但在content address的模型中，用于索引value的key是根据value的内容计算得来。content address最简单的例子就是使用文件的哈希值来索引文件，给定文件的哈希值，返回文件内容；&#xA;而input address典型例子就是给定文件的文件名，返回文件的内容；&lt;/p&gt;</description>
    </item>
    <item>
      <title>Way to Nix 1</title>
      <link>https://blog.razyang.com/posts/way-to-nix-1/</link>
      <pubDate>Fri, 01 Dec 2023 11:56:15 +0800</pubDate>
      <guid>https://blog.razyang.com/posts/way-to-nix-1/</guid>
      <description>&lt;p&gt;最近学习了一些Nix相关的东西，把家里大多数机器都切到了nixos上，感觉很不错。但是由于nix文档比较差，写自己配置的时候，很多时候需要看代码，或者抄别人的配置一点点凑，过程当中遇到了不少问题。也学习了不少Nix的基本概念，于是记录一下相关的概念和技术以免忘记。&lt;/p&gt;&#xA;&lt;p&gt;前阵子看过NickCao的前些年的一个视频，非常有条例的介绍了一些nix的基本概念，有兴趣可以去看一下：&lt;a href=&#34;https://b23.tv/vxaiTuS&#34;&gt;【金枪鱼之夜：Nix - 从构建系统到配置管理-哔哩哔哩】&lt;/a&gt;&lt;/p&gt;&#xA;&lt;h1 id=&#34;nix-as-a-build-systems&#34;&gt;Nix as a build systems&lt;/h1&gt;&#xA;&lt;p&gt;构建系统一般就是指从源码生成产物的一套工具生态集合，就拿Makefile举例，几乎所有的构建过程都可以描述成如下形式的嵌套结构：&lt;/p&gt;&#xA;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-Makefile&#34; data-lang=&#34;Makefile&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;构建目标&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;:&lt;/span&gt; 构建原料&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    构建过程&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;围绕着gnu make，有一套完整的，有着悠久历史的构建系统，如GNU Autoconf，Cmake等，许多现代语言也包含了自己的构建系统，如rust的cargo，go的build，js的npm等等。也会有许多项目选择多种构建系统嵌套，如Cmake生成makefile调用Cargo来进行项目构建。&lt;/p&gt;&#xA;&lt;h2 id=&#34;derivation&#34;&gt;Derivation&lt;/h2&gt;&#xA;&lt;p&gt;也许nix里最重要的概念就是&lt;a href=&#34;https://nixos.org/manual/nix/stable/language/derivations.html&#34;&gt;Derivation&lt;/a&gt;了，它与nix中的很多概念相互关联，并作为纽带。可以说理解了Derivation，至少就理解了Nix的半壁江山。&lt;/p&gt;&#xA;&lt;p&gt;首先， derivition是nix中的一个内置函数,代码实现位于(&lt;a href=&#34;https://github.com/NixOS/nix/blob/188c803ddb5e63b243ddb84eba9b70e45475b7ea/src/libexpr/primops/derivation.nix#L2&#34;&gt;https://github.com/NixOS/nix/blob/188c803ddb5e63b243ddb84eba9b70e45475b7ea/src/libexpr/primops/derivation.nix#L2&lt;/a&gt;)，实际调用的是内部C++函数&lt;a href=&#34;https://github.com/NixOS/nix/blob/188c803ddb5e63b243ddb84eba9b70e45475b7ea/src/libexpr/primops.cc#L1041&#34;&gt;prim_derivationStrict&lt;/a&gt;:&lt;/p&gt;&#xA;&lt;pre tabindex=&#34;0&#34;&gt;&lt;code class=&#34;language-repl&#34; data-lang=&#34;repl&#34;&gt;nix-repl&amp;gt; derivation&#xA;«lambda @ /builtin/derivation.nix:5:1»&#xA;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;与其他构建系统类似，derivation包含了构建原料，构建目标以及构建过程，调用这个函数必须有&lt;code&gt;name&lt;/code&gt;、&lt;code&gt;system&lt;/code&gt;以及&lt;code&gt;builder&lt;/code&gt;三个必选参数，其他可选参数可参考&lt;a href=&#34;https://nixos.org/manual/nix/stable/language/derivations.html#optional&#34;&gt;Nix Reference Manual&lt;/a&gt;:&lt;/p&gt;&#xA;&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;nix-repl&amp;gt; derivation {name = &amp;#34;target_name&amp;#34;;system=&amp;#34;x86_64-linux&amp;#34;; builder=&amp;#34;builder_binary&amp;#34;;}&#xA;«derivation /nix/store/6z9jj5khn7j3xi2fv8fibpzj6gnq4iz4-target_name.drv»&#xA;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;值得注意的是，derivation函数存在一个副作用，即在/nix/store/目录下生成一个以&lt;code&gt;.drv&lt;/code&gt;为后缀的文件，并且文件名中包含了一个类似哈希的字符串，保证路径的唯一性。derivation有如下属性:&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;同样参数的derivation函数调用后生成的文件，路径一定是一样的（&lt;em&gt;在哈希算法的保证下，可以假定不同参数调用derivation产生的drv文件路径一定是不同的&lt;/em&gt;）&lt;/li&gt;&#xA;&lt;li&gt;derivation中包含的所有参数必须为字面量，或预先可以确定哈希值的固定内容（&lt;strong&gt;Fixed-Output Derivations&lt;/strong&gt;）&lt;/li&gt;&#xA;&lt;li&gt;derivation可以互相依赖，一个derivation可以依赖另外一个derivation&lt;/li&gt;&#xA;&lt;li&gt;derivation可以被执行，类似Makefile一样可以被构建&lt;/li&gt;&#xA;&lt;li&gt;derivation会被在隔离的环境执行，其中没有类似&lt;code&gt;/bin/bash&lt;/code&gt;之类可以预先假定存在的路径，能且只能通过derivation依赖的方式在构建过程当中引入其他软件&lt;/li&gt;&#xA;&lt;li&gt;derivation执行后会产生两个关键参数，out.out以及out.outPath，一个存储了drv的路径，一个存储了构建产物的路径&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;nix-repl&amp;gt; d = derivation {name = &amp;#34;target_name&amp;#34;;system=&amp;#34;x86_64-linux&amp;#34;; builder=&amp;#34;builder_binary&amp;#34;;}&#xA;&#xA;nix-repl&amp;gt; d.out.out&#xA;«derivation /nix/store/6z9jj5khn7j3xi2fv8fibpzj6gnq4iz4-target_name.drv»&#xA;&#xA;nix-repl&amp;gt; d.out.outPath&#xA;&amp;#34;/nix/store/pd5l9rzb613v5lv4c6q2m0c81zd9w3l6-target_name&amp;#34;&#xA;&#xA;nix-repl&amp;gt; d.out.out == d&#xA;true&#xA;&#xA;nix-repl&amp;gt; d.out == d&#xA;true&#xA;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;以上属性组合的结果，使得nix构建系统存在如下特性：&lt;/p&gt;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;任何软件的derivation在/nix/store中的路径包含了唯一哈希值，这个路径实际上代表了产物是用&lt;code&gt;何种输入源&lt;/code&gt;，以&lt;code&gt;何种构建方式&lt;/code&gt;，配置&lt;code&gt;何种构建参数&lt;/code&gt;所构建出来的结果，且由于derivation之间互相依赖，整颗依赖树的任何一个环节发生了变化，重新构建后，derivation路径相应也会发生变化&lt;/li&gt;&#xA;&lt;li&gt;derivation既可以描述软件的构建过程，又可以描述多种软件组合称为操作系统的过程，进一步说，如果把操作系统当成目标产物，通过derivation的嵌套，nix可以描述出整个操作系统的构建过程，且在保证可完全可复现。&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&lt;h1 id=&#34;nix-as-programing-language&#34;&gt;Nix as programing language&lt;/h1&gt;&#xA;&lt;p&gt;与其他构建系统采用的语法风格不同的是，Nix采用了函数式语法，且没有类型系统，这也是Nix看起来比较吓人的主要原因&lt;/p&gt;</description>
    </item>
    <item>
      <title>叛逃</title>
      <link>https://blog.razyang.com/posts/defection/</link>
      <pubDate>Sun, 07 Aug 2022 12:52:43 +0800</pubDate>
      <guid>https://blog.razyang.com/posts/defection/</guid>
      <description>&lt;h1 id=&#34;所谓叛逃&#34;&gt;所谓叛逃&lt;/h1&gt;&#xA;&lt;p&gt;仔细想一想，自从上大学开始，我用linux做为日常工作和学习的系统也有将近六年了。&#xA;这六年来，常见的Linux发行版基本都装了个遍，常见的桌面环境和窗口管理器也基本用了个遍。&#xA;不过随着时间流逝，我逐渐发现，桌面环境折腾无数遍，其实实际在用的图形界面软件只有三个：&lt;code&gt;emacs&lt;/code&gt;、&lt;code&gt;chrome&lt;/code&gt;、&lt;code&gt;alacritty&lt;/code&gt;。&lt;/p&gt;&#xA;&lt;p&gt;更抽象一点的话，其实就是一个编辑器，一个浏览器还有一个终端模拟器。其他软件使用频率都非常低，最近两年内，我逐渐发现自己打开文件管理器的频率也越来越低，以至于文件管理器对于我日常的电脑使用来说，也成为了一个没有必要的软件。&lt;/p&gt;&#xA;&lt;p&gt;铺垫了这么多，其实我就是想说，爷叛逃了，到MacOS。&lt;/p&gt;&#xA;&lt;h1 id=&#34;目的地&#34;&gt;目的地&lt;/h1&gt;&#xA;&lt;p&gt;其实也没啥道理，最近想买一个笔记本，看了一圈。intel 11代摆大烂，12代功耗爆炸；AMD 6000系的笔记本，续航稍微好一些，但GPU硬件设计有问题。仔细想了一想，苹果的笔记本成了这两年唯一没重大问题，没开过什么倒车的设备了。&lt;/p&gt;&#xA;&lt;p&gt;所以，Macbook Air m2 16+512，请：&#xA;&lt;img src=&#34;2022-08-07_13.23.10.png&#34; alt=&#34;neofetch&#34;&gt;&lt;/p&gt;&#xA;&lt;h1 id=&#34;基本配置&#34;&gt;基本配置&lt;/h1&gt;&#xA;&lt;h2 id=&#34;终端应用&#34;&gt;终端应用&lt;/h2&gt;&#xA;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-sh&#34; data-lang=&#34;sh&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;brew install p7zip starship rustup-init tmux go coreutils grep startship bottom zoxide fzf ripgrep shellcheck starship hugo fd 7z pandoc neofetch&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;大概先装这么多吧，zsh配置后续再迁移过来&lt;/p&gt;&#xA;&lt;h2 id=&#34;gui&#34;&gt;GUI&lt;/h2&gt;&#xA;&lt;blockquote&gt;&#xA;&lt;p&gt;写这篇文章的时候突然恍然大悟，原来我能在这台电脑上装qq和微信，突然间一股惆怅的情绪涌上心头&lt;/p&gt;&#xA;&lt;/blockquote&gt;&#xA;&lt;p&gt;其实也没啥好装的，浏览器暂时看看safari表现怎么样了，之后如果不成的话再装chrome。&lt;/p&gt;&#xA;&lt;p&gt;文本编辑器的话，还是当之无愧的emacs。虽然在macos上的这个版本没有native compile，但是感觉响应速度没有什么明显区别：&lt;/p&gt;&#xA;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-sh&#34; data-lang=&#34;sh&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;brew install --cask emacs&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;</description>
    </item>
    <item>
      <title>Template Post</title>
      <link>https://blog.razyang.com/posts/template-post/</link>
      <pubDate>Thu, 04 Aug 2022 11:30:51 +0800</pubDate>
      <guid>https://blog.razyang.com/posts/template-post/</guid>
      <description>&lt;h1 id=&#34;segment&#34;&gt;segment&lt;/h1&gt;&#xA;&lt;h2 id=&#34;segment-1&#34;&gt;segment&lt;/h2&gt;&#xA;&lt;h3 id=&#34;segment-2&#34;&gt;segment&lt;/h3&gt;&#xA;&lt;h4 id=&#34;segment-3&#34;&gt;segment&lt;/h4&gt;&#xA;&lt;h3 id=&#34;text-style&#34;&gt;Text style&lt;/h3&gt;&#xA;&lt;p&gt;&lt;em&gt;This text is in italics.&lt;/em&gt;&#xA;&lt;em&gt;And so is this text.&lt;/em&gt;&lt;/p&gt;&#xA;&lt;p&gt;&lt;strong&gt;This text is in bold.&lt;/strong&gt;&#xA;&lt;strong&gt;And so is this text.&lt;/strong&gt;&lt;/p&gt;&#xA;&lt;p&gt;&lt;em&gt;&lt;strong&gt;This text is in both.&lt;/strong&gt;&lt;/em&gt;&#xA;&lt;strong&gt;&lt;em&gt;As is this!&lt;/em&gt;&lt;/strong&gt;&#xA;&lt;em&gt;&lt;strong&gt;And this!&lt;/strong&gt;&lt;/em&gt;&lt;/p&gt;&#xA;&lt;h3 id=&#34;paragraph&#34;&gt;Paragraph&lt;/h3&gt;&#xA;&lt;p&gt;This is a paragraph. I&amp;rsquo;m typing in a paragraph isn&amp;rsquo;t this fun?&lt;/p&gt;&#xA;&lt;p&gt;Now I&amp;rsquo;m in paragraph 2.&#xA;I&amp;rsquo;m still in paragraph 2 too!&lt;/p&gt;&#xA;&lt;p&gt;I&amp;rsquo;m in paragraph three!&lt;/p&gt;&#xA;&lt;blockquote&gt;&#xA;&lt;p&gt;This is a block quote. You can either&#xA;manually wrap your lines and put a &lt;code&gt;&amp;gt;&lt;/code&gt; before every line or you can let your lines get really long and wrap on their own.&#xA;It doesn&amp;rsquo;t make a difference so long as they start with a &lt;code&gt;&amp;gt;&lt;/code&gt;.&lt;/p&gt;</description>
    </item>
    <item>
      <title>Archive</title>
      <link>https://blog.razyang.com/archives/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://blog.razyang.com/archives/</guid>
      <description>archives</description>
    </item>
  </channel>
</rss>
